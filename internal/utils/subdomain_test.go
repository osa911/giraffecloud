package utils

import (
	"os"
	"strings"
	"testing"
)

func TestGenerateSubdomainForUser(t *testing.T) {
	// Set up test environment
	os.Setenv("SUBDOMAIN_SECRET", "test-secret-key")
	os.Setenv("CLIENT_URL", "https://test.example.com")
	defer func() {
		os.Unsetenv("SUBDOMAIN_SECRET")
		os.Unsetenv("CLIENT_URL")
	}()

	tests := []struct {
		name   string
		userID uint32
	}{
		{"User 1", 1},
		{"User 100", 100},
		{"User 12345", 12345},
		{"User 999999", 999999},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Generate subdomain
			subdomain1 := GenerateSubdomainForUser(tt.userID)

			// Verify format
			if !strings.HasSuffix(subdomain1, ".test.example.com") {
				t.Errorf("Subdomain doesn't end with base domain: %s", subdomain1)
			}

			// Verify it has the expected format (word-word-hash)
			parts := strings.Split(strings.TrimSuffix(subdomain1, ".test.example.com"), "-")
			if len(parts) != 3 {
				t.Errorf("Expected format: word-word-hash, got: %s", subdomain1)
			}

			// Verify determinism - same user ID should always generate same subdomain
			subdomain2 := GenerateSubdomainForUser(tt.userID)
			if subdomain1 != subdomain2 {
				t.Errorf("Non-deterministic generation: %s != %s", subdomain1, subdomain2)
			}

			t.Logf("User %d -> %s", tt.userID, subdomain1)
		})
	}
}

func TestGenerateSubdomainForUser_Uniqueness(t *testing.T) {
	os.Setenv("SUBDOMAIN_SECRET", "test-secret-key")
	os.Setenv("CLIENT_URL", "https://test.example.com")
	defer func() {
		os.Unsetenv("SUBDOMAIN_SECRET")
		os.Unsetenv("CLIENT_URL")
	}()

	// Generate subdomains for different users
	seen := make(map[string]uint32)
	collisions := 0

	for i := uint32(1); i <= 1000; i++ {
		subdomain := GenerateSubdomainForUser(i)
		if existingUserID, exists := seen[subdomain]; exists {
			collisions++
			t.Logf("Collision detected: User %d and User %d both got %s", i, existingUserID, subdomain)
		}
		seen[subdomain] = i
	}

	t.Logf("Generated 1000 subdomains with %d collisions", collisions)

	// We expect 0 collisions since we're using HMAC with user ID included in hash
	if collisions > 0 {
		t.Errorf("Expected 0 collisions, got %d", collisions)
	}
}

func TestIsAutoGeneratedDomain(t *testing.T) {
	os.Setenv("CLIENT_URL", "https://test.example.com")
	defer os.Unsetenv("CLIENT_URL")

	tests := []struct {
		name     string
		domain   string
		expected bool
	}{
		{"Auto-generated domain", "happy-giraffe-abc123.test.example.com", true},
		{"Custom domain", "mycustomdomain.com", false},
		{"Base domain itself", "test.example.com", false},
		{"Subdomain of different domain", "something.otherdomain.com", false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := IsAutoGeneratedDomain(tt.domain)
			if result != tt.expected {
				t.Errorf("IsAutoGeneratedDomain(%s) = %v, expected %v", tt.domain, result, tt.expected)
			}
		})
	}
}

func TestExtractSubdomain(t *testing.T) {
	os.Setenv("CLIENT_URL", "https://test.example.com")
	defer os.Unsetenv("CLIENT_URL")

	tests := []struct {
		name     string
		domain   string
		expected string
	}{
		{"Valid auto-generated", "happy-giraffe-abc123.test.example.com", "happy-giraffe-abc123"},
		{"Custom domain", "mycustomdomain.com", ""},
		{"Base domain", "test.example.com", ""},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := ExtractSubdomain(tt.domain)
			if result != tt.expected {
				t.Errorf("ExtractSubdomain(%s) = %s, expected %s", tt.domain, result, tt.expected)
			}
		})
	}
}

func TestGenerateSubdomainForUser_DifferentSecrets(t *testing.T) {
	os.Setenv("CLIENT_URL", "https://test.example.com")
	defer os.Unsetenv("CLIENT_URL")

	userID := uint32(12345)

	// Generate with first secret
	os.Setenv("SUBDOMAIN_SECRET", "secret1")
	subdomain1 := GenerateSubdomainForUser(userID)

	// Generate with second secret
	os.Setenv("SUBDOMAIN_SECRET", "secret2")
	subdomain2 := GenerateSubdomainForUser(userID)

	os.Unsetenv("SUBDOMAIN_SECRET")

	// Different secrets should produce different subdomains for same user
	if subdomain1 == subdomain2 {
		t.Errorf("Different secrets produced same subdomain: %s", subdomain1)
	}

	t.Logf("Secret1: %s", subdomain1)
	t.Logf("Secret2: %s", subdomain2)
}
