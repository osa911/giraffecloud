package service

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"os"

	"github.com/osa911/giraffecloud/internal/db/ent"
	"github.com/osa911/giraffecloud/internal/interfaces"
	"github.com/osa911/giraffecloud/internal/logging"
	"github.com/osa911/giraffecloud/internal/repository"
	"github.com/osa911/giraffecloud/internal/utils"
)

type tunnelService struct {
	repo         repository.TunnelRepository
	caddyService CaddyService
}

// NewTunnelService creates a new tunnel service instance
func NewTunnelService(repo repository.TunnelRepository, caddyService CaddyService) interfaces.TunnelService {
	return &tunnelService{
		repo:         repo,
		caddyService: caddyService,
	}
}

// generateToken generates a random token for tunnel authentication
func generateToken() (string, error) {
	bytes := make([]byte, 32)
	if _, err := rand.Read(bytes); err != nil {
		return "", err
	}
	return hex.EncodeToString(bytes), nil
}

// GetFreeSubdomain returns the auto-generated subdomain for a user
// Returns the existing subdomain if user already has one, or generates a new one
func (s *tunnelService) GetFreeSubdomain(ctx context.Context, userID uint32) (domain string, available bool, err error) {
	logger := logging.GetGlobalLogger()

	// Check if user already has an auto-generated tunnel
	tunnels, err := s.repo.GetByUserID(ctx, userID)
	if err != nil {
		return "", false, fmt.Errorf("failed to check existing tunnels: %w", err)
	}

	for _, tunnel := range tunnels {
		if utils.IsAutoGeneratedDomain(tunnel.Domain) {
			logger.Info("User %d already has an auto-generated subdomain: %s", userID, tunnel.Domain)
			return tunnel.Domain, false, nil
		}
	}

	// Generate deterministic subdomain for this user
	subdomain := utils.GenerateSubdomainForUser(userID)
	logger.Info("Generated free subdomain for user %d: %s", userID, subdomain)

	return subdomain, true, nil
}

// isReservedDomain checks if the domain matches reserved system domains
// Reserved domains are derived from CLIENT_URL environment variable
func isReservedDomain(domain string) bool {
	logger := logging.GetGlobalLogger()

	// Get base domain from CLIENT_URL (e.g., "giraffecloud.xyz" from "https://giraffecloud.xyz")
	clientURL := os.Getenv("CLIENT_URL")
	if clientURL == "" {
		logger.Warn("CLIENT_URL not set, using hardcoded reserved domains")
		// Fallback to hardcoded domains if CLIENT_URL is not set
		reservedDomains := []string{
			"giraffecloud.xyz",
			"www.giraffecloud.xyz",
			"api.giraffecloud.xyz",
			"tunnel.giraffecloud.xyz",
		}
		for _, reserved := range reservedDomains {
			if domain == reserved {
				return true
			}
		}
		return false
	}

	baseDomain := utils.GetBaseDomain()
	if baseDomain == "" || baseDomain == "localhost" {
		logger.Warn("Failed to get base domain from CLIENT_URL: %s", clientURL)
		return false
	}

	// Build reserved domains from base domain
	reservedDomains := []string{
		baseDomain,             // giraffecloud.xyz
		"www." + baseDomain,    // www.giraffecloud.xyz
		"api." + baseDomain,    // api.giraffecloud.xyz
		"tunnel." + baseDomain, // tunnel.giraffecloud.xyz
	}

	for _, reserved := range reservedDomains {
		if domain == reserved {
			return true
		}
	}
	return false
}

// CreateTunnel creates a new tunnel
func (s *tunnelService) CreateTunnel(ctx context.Context, userID uint32, domain string, targetPort int) (*ent.Tunnel, error) {
	logger := logging.GetGlobalLogger()

	// Validate domain is not a reserved system domain
	if isReservedDomain(domain) {
		logger.Warn("User %d attempted to create tunnel with reserved domain: %s", userID, domain)
		return nil, fmt.Errorf("domain '%s' is reserved for system use and cannot be used for tunnels", domain)
	}

	// Get all existing tunnels for this user
	tunnels, err := s.repo.GetByUserID(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to check existing tunnels: %w", err)
	}

	// Validate target port is not already in use by this user
	for _, tunnel := range tunnels {
		if tunnel.TargetPort == targetPort {
			logger.Warn("User %d attempted to create tunnel with duplicate port %d", userID, targetPort)
			return nil, fmt.Errorf("you already have a tunnel using port %d", targetPort)
		}
	}

	// If this is an auto-generated domain, validate it
	if utils.IsAutoGeneratedDomain(domain) {
		// Verify user doesn't already have an auto-generated tunnel
		for _, tunnel := range tunnels {
			if utils.IsAutoGeneratedDomain(tunnel.Domain) {
				return nil, fmt.Errorf("user already has an auto-generated subdomain tunnel")
			}
		}

		// Verify this is the correct auto-generated domain for this user
		expectedDomain := utils.GenerateSubdomainForUser(userID)
		if domain != expectedDomain {
			logger.Warn("User %d attempted to create tunnel with incorrect auto-generated domain: %s (expected: %s)",
				userID, domain, expectedDomain)
			return nil, fmt.Errorf("invalid auto-generated domain for this user")
		}

		logger.Info("Creating auto-generated tunnel for user %d: %s", userID, domain)
	} else {
		logger.Info("Creating custom domain tunnel for user %d: %s", userID, domain)
	}

	token, err := generateToken()
	if err != nil {
		return nil, fmt.Errorf("failed to generate token: %w", err)
	}

	tunnel := &ent.Tunnel{
		Domain:     domain,
		Token:      token,
		TargetPort: targetPort,
		IsEnabled:  true,
		UserID:     userID,
	}

	// Create tunnel in database only
	tunnel, err = s.repo.Create(ctx, tunnel)
	if err != nil {
		return nil, fmt.Errorf("failed to create tunnel: %w", err)
	}

	logger.Info("Successfully created tunnel ID %d with domain: %s", tunnel.ID, tunnel.Domain)
	return tunnel, nil
}

// ListTunnels lists all tunnels for a user
func (s *tunnelService) ListTunnels(ctx context.Context, userID uint32) ([]*ent.Tunnel, error) {
	return s.repo.GetByUserID(ctx, userID)
}

// GetTunnel gets a specific tunnel
func (s *tunnelService) GetTunnel(ctx context.Context, userID uint32, tunnelID uint32) (*ent.Tunnel, error) {
	return s.repo.GetByID(ctx, tunnelID)
}

// DeleteTunnel deletes a tunnel
func (s *tunnelService) DeleteTunnel(ctx context.Context, userID uint32, tunnelID uint32) error {
	// Get tunnel first to get the domain
	tunnel, err := s.repo.GetByID(ctx, tunnelID)
	if err != nil {
		return fmt.Errorf("failed to get tunnel: %w", err)
	}

	// Remove Caddy route if tunnel is enabled and has a client IP
	if tunnel.IsEnabled && tunnel.ClientIP != "" && s.caddyService != nil {
		if err := s.caddyService.RemoveRoute(tunnel.Domain); err != nil {
			// Log error but don't fail the deletion
			fmt.Printf("Warning: Failed to remove Caddy route: %v\n", err)
		}
	}

	return s.repo.Delete(ctx, tunnelID)
}

// UpdateTunnel updates a tunnel's configuration
func (s *tunnelService) UpdateTunnel(ctx context.Context, userID uint32, tunnelID uint32, updates interface{}) (*ent.Tunnel, error) {
	logger := logging.GetGlobalLogger()
	logger.Info("[DEBUG] UpdateTunnel called for tunnelID=%d, userID=%d", tunnelID, userID)

	// Get current tunnel state
	currentTunnel, err := s.repo.GetByID(ctx, tunnelID)
	if err != nil {
		logger.Error("[DEBUG] Failed to get tunnel: %v", err)
		return nil, fmt.Errorf("failed to get tunnel: %w", err)
	}

	// Validate port uniqueness if port is being updated
	if u, ok := updates.(*repository.TunnelUpdate); ok && u.TargetPort != nil {
		newPort := *u.TargetPort
		// Only validate if port is actually changing
		if newPort != currentTunnel.TargetPort {
			// Check if another tunnel for this user already uses this port
			tunnels, err := s.repo.GetByUserID(ctx, userID)
			if err != nil {
				return nil, fmt.Errorf("failed to check existing tunnels: %w", err)
			}
			for _, tunnel := range tunnels {
				if tunnel.ID != int(tunnelID) && tunnel.TargetPort == newPort {
					logger.Warn("User %d attempted to update tunnel %d to duplicate port %d", userID, tunnelID, newPort)
					return nil, fmt.Errorf("you already have a tunnel using port %d", newPort)
				}
			}
		}
	}

	// Update tunnel in database
	tunnel, err := s.repo.Update(ctx, tunnelID, updates)
	if err != nil {
		logger.Error("[DEBUG] Failed to update tunnel: %v", err)
		return nil, fmt.Errorf("failed to update tunnel: %w", err)
	}

	// Handle Caddy configuration updates if client is connected
	if tunnel.ClientIP != "" && s.caddyService != nil {
		logger.Info("[DEBUG] Handling Caddy configuration for tunnel %d, domain: %s, IP: %s", tunnelID, tunnel.Domain, tunnel.ClientIP)
		if tunnel.IsEnabled {
			// Configure/update route if tunnel is enabled
			if err := s.caddyService.ConfigureRoute(tunnel.Domain, tunnel.ClientIP, tunnel.TargetPort); err != nil {
				logger.Error("[DEBUG] Failed to configure Caddy route: %v", err)
			} else {
				logger.Info("[DEBUG] Successfully configured Caddy route for domain: %s", tunnel.Domain)
			}
		} else if currentTunnel.IsEnabled {
			// Remove route if tunnel was disabled
			if err := s.caddyService.RemoveRoute(tunnel.Domain); err != nil {
				logger.Error("[DEBUG] Failed to remove Caddy route: %v", err)
			} else {
				logger.Info("[DEBUG] Successfully removed Caddy route for domain: %s", tunnel.Domain)
			}
		}
	} else {
		if s.caddyService == nil {
			logger.Warn("[DEBUG] Caddy service is nil, skipping route configuration")
		}
		if tunnel.ClientIP == "" {
			logger.Info("[DEBUG] No client IP set, skipping Caddy configuration")
		}
	}

	return tunnel, nil
}

// GetByToken gets a tunnel by its token
func (s *tunnelService) GetByToken(ctx context.Context, token string) (*ent.Tunnel, error) {
	return s.repo.GetByToken(ctx, token)
}

// GetByDomain retrieves a tunnel by its domain
func (s *tunnelService) GetByDomain(ctx context.Context, domain string) (*ent.Tunnel, error) {
	return s.repo.GetByDomain(ctx, domain)
}

// UpdateClientIP updates a tunnel's client IP and configures Caddy route
func (s *tunnelService) UpdateClientIP(ctx context.Context, id uint32, clientIP string) error {
	logger := logging.GetGlobalLogger()
	logger.Info("[DEBUG] UpdateClientIP called for tunnel %d with IP %s", id, clientIP)

	// Get current tunnel state
	tunnel, err := s.repo.GetByID(ctx, id)
	if err != nil {
		logger.Error("[DEBUG] Failed to get tunnel: %v", err)
		return fmt.Errorf("failed to get tunnel: %w", err)
	}

	logger.Info("[DEBUG] Current tunnel state - Domain: %s, Enabled: %v, CurrentIP: %s", tunnel.Domain, tunnel.IsEnabled, tunnel.ClientIP)

	// Update client IP in database
	if err := s.repo.UpdateClientIP(ctx, id, clientIP); err != nil {
		logger.Error("[DEBUG] Failed to update client IP in database: %v", err)
		return fmt.Errorf("failed to update client IP: %w", err)
	}

	logger.Info("[DEBUG] Successfully updated client IP in database")

	// Configure or remove Caddy route based on client IP
	if s.caddyService != nil {
		logger.Info("[DEBUG] Caddy service is available")
		if clientIP != "" && tunnel.IsEnabled {
			logger.Info("[DEBUG] Configuring Caddy route for domain: %s -> %s:%d", tunnel.Domain, clientIP, tunnel.TargetPort)
			// Configure route when client connects
			if err := s.caddyService.ConfigureRoute(tunnel.Domain, clientIP, tunnel.TargetPort); err != nil {
				logger.Error("[DEBUG] Failed to configure Caddy route: %v", err)
				return fmt.Errorf("failed to configure Caddy route: %w", err)
			}
			logger.Info("[DEBUG] Successfully configured Caddy route")
		} else {
			logger.Info("[DEBUG] Removing Caddy route for domain: %s", tunnel.Domain)
			// Remove route when client disconnects
			if err := s.caddyService.RemoveRoute(tunnel.Domain); err != nil {
				logger.Error("[DEBUG] Failed to remove Caddy route: %v", err)
				return fmt.Errorf("failed to remove Caddy route: %w", err)
			}
			logger.Info("[DEBUG] Successfully removed Caddy route")
		}
	} else {
		logger.Warn("[DEBUG] Caddy service is nil, skipping route configuration")
	}

	return nil
}

// GetActive gets all active tunnels
func (s *tunnelService) GetActive(ctx context.Context) ([]*ent.Tunnel, error) {
	return s.repo.GetActive(ctx)
}
