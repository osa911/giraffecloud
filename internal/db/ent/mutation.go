// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"giraffecloud/internal/db/ent/clientversion"
	"giraffecloud/internal/db/ent/plan"
	"giraffecloud/internal/db/ent/predicate"
	"giraffecloud/internal/db/ent/session"
	"giraffecloud/internal/db/ent/token"
	"giraffecloud/internal/db/ent/tunnel"
	"giraffecloud/internal/db/ent/usage"
	"giraffecloud/internal/db/ent/user"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeClientVersion = "ClientVersion"
	TypePlan          = "Plan"
	TypeSession       = "Session"
	TypeToken         = "Token"
	TypeTunnel        = "Tunnel"
	TypeUsage         = "Usage"
	TypeUser          = "User"
)

// ClientVersionMutation represents an operation that mutates the ClientVersion nodes in the graph.
type ClientVersionMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	channel             *string
	platform            *string
	arch                *string
	latest_version      *string
	minimum_version     *string
	download_url        *string
	release_notes       *string
	auto_update_enabled *bool
	force_update        *bool
	metadata            *map[string]interface{}
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*ClientVersion, error)
	predicates          []predicate.ClientVersion
}

var _ ent.Mutation = (*ClientVersionMutation)(nil)

// clientversionOption allows management of the mutation configuration using functional options.
type clientversionOption func(*ClientVersionMutation)

// newClientVersionMutation creates new mutation for the ClientVersion entity.
func newClientVersionMutation(c config, op Op, opts ...clientversionOption) *ClientVersionMutation {
	m := &ClientVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeClientVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClientVersionID sets the ID field of the mutation.
func withClientVersionID(id string) clientversionOption {
	return func(m *ClientVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *ClientVersion
		)
		m.oldValue = func(ctx context.Context) (*ClientVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ClientVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClientVersion sets the old ClientVersion of the mutation.
func withClientVersion(node *ClientVersion) clientversionOption {
	return func(m *ClientVersionMutation) {
		m.oldValue = func(context.Context) (*ClientVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClientVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClientVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ClientVersion entities.
func (m *ClientVersionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClientVersionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClientVersionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ClientVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetChannel sets the "channel" field.
func (m *ClientVersionMutation) SetChannel(s string) {
	m.channel = &s
}

// Channel returns the value of the "channel" field in the mutation.
func (m *ClientVersionMutation) Channel() (r string, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the ClientVersion entity.
// If the ClientVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientVersionMutation) OldChannel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ResetChannel resets all changes to the "channel" field.
func (m *ClientVersionMutation) ResetChannel() {
	m.channel = nil
}

// SetPlatform sets the "platform" field.
func (m *ClientVersionMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *ClientVersionMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the ClientVersion entity.
// If the ClientVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientVersionMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *ClientVersionMutation) ResetPlatform() {
	m.platform = nil
}

// SetArch sets the "arch" field.
func (m *ClientVersionMutation) SetArch(s string) {
	m.arch = &s
}

// Arch returns the value of the "arch" field in the mutation.
func (m *ClientVersionMutation) Arch() (r string, exists bool) {
	v := m.arch
	if v == nil {
		return
	}
	return *v, true
}

// OldArch returns the old "arch" field's value of the ClientVersion entity.
// If the ClientVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientVersionMutation) OldArch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArch: %w", err)
	}
	return oldValue.Arch, nil
}

// ResetArch resets all changes to the "arch" field.
func (m *ClientVersionMutation) ResetArch() {
	m.arch = nil
}

// SetLatestVersion sets the "latest_version" field.
func (m *ClientVersionMutation) SetLatestVersion(s string) {
	m.latest_version = &s
}

// LatestVersion returns the value of the "latest_version" field in the mutation.
func (m *ClientVersionMutation) LatestVersion() (r string, exists bool) {
	v := m.latest_version
	if v == nil {
		return
	}
	return *v, true
}

// OldLatestVersion returns the old "latest_version" field's value of the ClientVersion entity.
// If the ClientVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientVersionMutation) OldLatestVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatestVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatestVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatestVersion: %w", err)
	}
	return oldValue.LatestVersion, nil
}

// ResetLatestVersion resets all changes to the "latest_version" field.
func (m *ClientVersionMutation) ResetLatestVersion() {
	m.latest_version = nil
}

// SetMinimumVersion sets the "minimum_version" field.
func (m *ClientVersionMutation) SetMinimumVersion(s string) {
	m.minimum_version = &s
}

// MinimumVersion returns the value of the "minimum_version" field in the mutation.
func (m *ClientVersionMutation) MinimumVersion() (r string, exists bool) {
	v := m.minimum_version
	if v == nil {
		return
	}
	return *v, true
}

// OldMinimumVersion returns the old "minimum_version" field's value of the ClientVersion entity.
// If the ClientVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientVersionMutation) OldMinimumVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinimumVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinimumVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinimumVersion: %w", err)
	}
	return oldValue.MinimumVersion, nil
}

// ResetMinimumVersion resets all changes to the "minimum_version" field.
func (m *ClientVersionMutation) ResetMinimumVersion() {
	m.minimum_version = nil
}

// SetDownloadURL sets the "download_url" field.
func (m *ClientVersionMutation) SetDownloadURL(s string) {
	m.download_url = &s
}

// DownloadURL returns the value of the "download_url" field in the mutation.
func (m *ClientVersionMutation) DownloadURL() (r string, exists bool) {
	v := m.download_url
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadURL returns the old "download_url" field's value of the ClientVersion entity.
// If the ClientVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientVersionMutation) OldDownloadURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadURL: %w", err)
	}
	return oldValue.DownloadURL, nil
}

// ResetDownloadURL resets all changes to the "download_url" field.
func (m *ClientVersionMutation) ResetDownloadURL() {
	m.download_url = nil
}

// SetReleaseNotes sets the "release_notes" field.
func (m *ClientVersionMutation) SetReleaseNotes(s string) {
	m.release_notes = &s
}

// ReleaseNotes returns the value of the "release_notes" field in the mutation.
func (m *ClientVersionMutation) ReleaseNotes() (r string, exists bool) {
	v := m.release_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldReleaseNotes returns the old "release_notes" field's value of the ClientVersion entity.
// If the ClientVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientVersionMutation) OldReleaseNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleaseNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleaseNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleaseNotes: %w", err)
	}
	return oldValue.ReleaseNotes, nil
}

// ClearReleaseNotes clears the value of the "release_notes" field.
func (m *ClientVersionMutation) ClearReleaseNotes() {
	m.release_notes = nil
	m.clearedFields[clientversion.FieldReleaseNotes] = struct{}{}
}

// ReleaseNotesCleared returns if the "release_notes" field was cleared in this mutation.
func (m *ClientVersionMutation) ReleaseNotesCleared() bool {
	_, ok := m.clearedFields[clientversion.FieldReleaseNotes]
	return ok
}

// ResetReleaseNotes resets all changes to the "release_notes" field.
func (m *ClientVersionMutation) ResetReleaseNotes() {
	m.release_notes = nil
	delete(m.clearedFields, clientversion.FieldReleaseNotes)
}

// SetAutoUpdateEnabled sets the "auto_update_enabled" field.
func (m *ClientVersionMutation) SetAutoUpdateEnabled(b bool) {
	m.auto_update_enabled = &b
}

// AutoUpdateEnabled returns the value of the "auto_update_enabled" field in the mutation.
func (m *ClientVersionMutation) AutoUpdateEnabled() (r bool, exists bool) {
	v := m.auto_update_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoUpdateEnabled returns the old "auto_update_enabled" field's value of the ClientVersion entity.
// If the ClientVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientVersionMutation) OldAutoUpdateEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoUpdateEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoUpdateEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoUpdateEnabled: %w", err)
	}
	return oldValue.AutoUpdateEnabled, nil
}

// ResetAutoUpdateEnabled resets all changes to the "auto_update_enabled" field.
func (m *ClientVersionMutation) ResetAutoUpdateEnabled() {
	m.auto_update_enabled = nil
}

// SetForceUpdate sets the "force_update" field.
func (m *ClientVersionMutation) SetForceUpdate(b bool) {
	m.force_update = &b
}

// ForceUpdate returns the value of the "force_update" field in the mutation.
func (m *ClientVersionMutation) ForceUpdate() (r bool, exists bool) {
	v := m.force_update
	if v == nil {
		return
	}
	return *v, true
}

// OldForceUpdate returns the old "force_update" field's value of the ClientVersion entity.
// If the ClientVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientVersionMutation) OldForceUpdate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForceUpdate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForceUpdate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForceUpdate: %w", err)
	}
	return oldValue.ForceUpdate, nil
}

// ResetForceUpdate resets all changes to the "force_update" field.
func (m *ClientVersionMutation) ResetForceUpdate() {
	m.force_update = nil
}

// SetMetadata sets the "metadata" field.
func (m *ClientVersionMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ClientVersionMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the ClientVersion entity.
// If the ClientVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientVersionMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *ClientVersionMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[clientversion.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *ClientVersionMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[clientversion.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ClientVersionMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, clientversion.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *ClientVersionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ClientVersionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ClientVersion entity.
// If the ClientVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientVersionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ClientVersionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ClientVersionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ClientVersionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ClientVersion entity.
// If the ClientVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientVersionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ClientVersionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ClientVersionMutation builder.
func (m *ClientVersionMutation) Where(ps ...predicate.ClientVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClientVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClientVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ClientVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClientVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClientVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ClientVersion).
func (m *ClientVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClientVersionMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.channel != nil {
		fields = append(fields, clientversion.FieldChannel)
	}
	if m.platform != nil {
		fields = append(fields, clientversion.FieldPlatform)
	}
	if m.arch != nil {
		fields = append(fields, clientversion.FieldArch)
	}
	if m.latest_version != nil {
		fields = append(fields, clientversion.FieldLatestVersion)
	}
	if m.minimum_version != nil {
		fields = append(fields, clientversion.FieldMinimumVersion)
	}
	if m.download_url != nil {
		fields = append(fields, clientversion.FieldDownloadURL)
	}
	if m.release_notes != nil {
		fields = append(fields, clientversion.FieldReleaseNotes)
	}
	if m.auto_update_enabled != nil {
		fields = append(fields, clientversion.FieldAutoUpdateEnabled)
	}
	if m.force_update != nil {
		fields = append(fields, clientversion.FieldForceUpdate)
	}
	if m.metadata != nil {
		fields = append(fields, clientversion.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, clientversion.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, clientversion.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClientVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case clientversion.FieldChannel:
		return m.Channel()
	case clientversion.FieldPlatform:
		return m.Platform()
	case clientversion.FieldArch:
		return m.Arch()
	case clientversion.FieldLatestVersion:
		return m.LatestVersion()
	case clientversion.FieldMinimumVersion:
		return m.MinimumVersion()
	case clientversion.FieldDownloadURL:
		return m.DownloadURL()
	case clientversion.FieldReleaseNotes:
		return m.ReleaseNotes()
	case clientversion.FieldAutoUpdateEnabled:
		return m.AutoUpdateEnabled()
	case clientversion.FieldForceUpdate:
		return m.ForceUpdate()
	case clientversion.FieldMetadata:
		return m.Metadata()
	case clientversion.FieldCreatedAt:
		return m.CreatedAt()
	case clientversion.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClientVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case clientversion.FieldChannel:
		return m.OldChannel(ctx)
	case clientversion.FieldPlatform:
		return m.OldPlatform(ctx)
	case clientversion.FieldArch:
		return m.OldArch(ctx)
	case clientversion.FieldLatestVersion:
		return m.OldLatestVersion(ctx)
	case clientversion.FieldMinimumVersion:
		return m.OldMinimumVersion(ctx)
	case clientversion.FieldDownloadURL:
		return m.OldDownloadURL(ctx)
	case clientversion.FieldReleaseNotes:
		return m.OldReleaseNotes(ctx)
	case clientversion.FieldAutoUpdateEnabled:
		return m.OldAutoUpdateEnabled(ctx)
	case clientversion.FieldForceUpdate:
		return m.OldForceUpdate(ctx)
	case clientversion.FieldMetadata:
		return m.OldMetadata(ctx)
	case clientversion.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case clientversion.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ClientVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClientVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case clientversion.FieldChannel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case clientversion.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case clientversion.FieldArch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArch(v)
		return nil
	case clientversion.FieldLatestVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatestVersion(v)
		return nil
	case clientversion.FieldMinimumVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinimumVersion(v)
		return nil
	case clientversion.FieldDownloadURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadURL(v)
		return nil
	case clientversion.FieldReleaseNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleaseNotes(v)
		return nil
	case clientversion.FieldAutoUpdateEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoUpdateEnabled(v)
		return nil
	case clientversion.FieldForceUpdate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForceUpdate(v)
		return nil
	case clientversion.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case clientversion.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case clientversion.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ClientVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClientVersionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClientVersionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClientVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ClientVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClientVersionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(clientversion.FieldReleaseNotes) {
		fields = append(fields, clientversion.FieldReleaseNotes)
	}
	if m.FieldCleared(clientversion.FieldMetadata) {
		fields = append(fields, clientversion.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClientVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClientVersionMutation) ClearField(name string) error {
	switch name {
	case clientversion.FieldReleaseNotes:
		m.ClearReleaseNotes()
		return nil
	case clientversion.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown ClientVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClientVersionMutation) ResetField(name string) error {
	switch name {
	case clientversion.FieldChannel:
		m.ResetChannel()
		return nil
	case clientversion.FieldPlatform:
		m.ResetPlatform()
		return nil
	case clientversion.FieldArch:
		m.ResetArch()
		return nil
	case clientversion.FieldLatestVersion:
		m.ResetLatestVersion()
		return nil
	case clientversion.FieldMinimumVersion:
		m.ResetMinimumVersion()
		return nil
	case clientversion.FieldDownloadURL:
		m.ResetDownloadURL()
		return nil
	case clientversion.FieldReleaseNotes:
		m.ResetReleaseNotes()
		return nil
	case clientversion.FieldAutoUpdateEnabled:
		m.ResetAutoUpdateEnabled()
		return nil
	case clientversion.FieldForceUpdate:
		m.ResetForceUpdate()
		return nil
	case clientversion.FieldMetadata:
		m.ResetMetadata()
		return nil
	case clientversion.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case clientversion.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ClientVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClientVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClientVersionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClientVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClientVersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClientVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClientVersionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClientVersionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ClientVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClientVersionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ClientVersion edge %s", name)
}

// PlanMutation represents an operation that mutates the Plan nodes in the graph.
type PlanMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	created_at              *time.Time
	updated_at              *time.Time
	name                    *string
	monthly_limit_bytes     *int64
	addmonthly_limit_bytes  *int64
	overage_per_gb_cents    *int
	addoverage_per_gb_cents *int
	active                  *bool
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*Plan, error)
	predicates              []predicate.Plan
}

var _ ent.Mutation = (*PlanMutation)(nil)

// planOption allows management of the mutation configuration using functional options.
type planOption func(*PlanMutation)

// newPlanMutation creates new mutation for the Plan entity.
func newPlanMutation(c config, op Op, opts ...planOption) *PlanMutation {
	m := &PlanMutation{
		config:        c,
		op:            op,
		typ:           TypePlan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlanID sets the ID field of the mutation.
func withPlanID(id int) planOption {
	return func(m *PlanMutation) {
		var (
			err   error
			once  sync.Once
			value *Plan
		)
		m.oldValue = func(ctx context.Context) (*Plan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Plan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlan sets the old Plan of the mutation.
func withPlan(node *Plan) planOption {
	return func(m *PlanMutation) {
		m.oldValue = func(context.Context) (*Plan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlanMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlanMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Plan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PlanMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlanMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlanMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlanMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlanMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlanMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *PlanMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlanMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlanMutation) ResetName() {
	m.name = nil
}

// SetMonthlyLimitBytes sets the "monthly_limit_bytes" field.
func (m *PlanMutation) SetMonthlyLimitBytes(i int64) {
	m.monthly_limit_bytes = &i
	m.addmonthly_limit_bytes = nil
}

// MonthlyLimitBytes returns the value of the "monthly_limit_bytes" field in the mutation.
func (m *PlanMutation) MonthlyLimitBytes() (r int64, exists bool) {
	v := m.monthly_limit_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldMonthlyLimitBytes returns the old "monthly_limit_bytes" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldMonthlyLimitBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMonthlyLimitBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMonthlyLimitBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonthlyLimitBytes: %w", err)
	}
	return oldValue.MonthlyLimitBytes, nil
}

// AddMonthlyLimitBytes adds i to the "monthly_limit_bytes" field.
func (m *PlanMutation) AddMonthlyLimitBytes(i int64) {
	if m.addmonthly_limit_bytes != nil {
		*m.addmonthly_limit_bytes += i
	} else {
		m.addmonthly_limit_bytes = &i
	}
}

// AddedMonthlyLimitBytes returns the value that was added to the "monthly_limit_bytes" field in this mutation.
func (m *PlanMutation) AddedMonthlyLimitBytes() (r int64, exists bool) {
	v := m.addmonthly_limit_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetMonthlyLimitBytes resets all changes to the "monthly_limit_bytes" field.
func (m *PlanMutation) ResetMonthlyLimitBytes() {
	m.monthly_limit_bytes = nil
	m.addmonthly_limit_bytes = nil
}

// SetOveragePerGBCents sets the "overage_per_gb_cents" field.
func (m *PlanMutation) SetOveragePerGBCents(i int) {
	m.overage_per_gb_cents = &i
	m.addoverage_per_gb_cents = nil
}

// OveragePerGBCents returns the value of the "overage_per_gb_cents" field in the mutation.
func (m *PlanMutation) OveragePerGBCents() (r int, exists bool) {
	v := m.overage_per_gb_cents
	if v == nil {
		return
	}
	return *v, true
}

// OldOveragePerGBCents returns the old "overage_per_gb_cents" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldOveragePerGBCents(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOveragePerGBCents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOveragePerGBCents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOveragePerGBCents: %w", err)
	}
	return oldValue.OveragePerGBCents, nil
}

// AddOveragePerGBCents adds i to the "overage_per_gb_cents" field.
func (m *PlanMutation) AddOveragePerGBCents(i int) {
	if m.addoverage_per_gb_cents != nil {
		*m.addoverage_per_gb_cents += i
	} else {
		m.addoverage_per_gb_cents = &i
	}
}

// AddedOveragePerGBCents returns the value that was added to the "overage_per_gb_cents" field in this mutation.
func (m *PlanMutation) AddedOveragePerGBCents() (r int, exists bool) {
	v := m.addoverage_per_gb_cents
	if v == nil {
		return
	}
	return *v, true
}

// ResetOveragePerGBCents resets all changes to the "overage_per_gb_cents" field.
func (m *PlanMutation) ResetOveragePerGBCents() {
	m.overage_per_gb_cents = nil
	m.addoverage_per_gb_cents = nil
}

// SetActive sets the "active" field.
func (m *PlanMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *PlanMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *PlanMutation) ResetActive() {
	m.active = nil
}

// Where appends a list predicates to the PlanMutation builder.
func (m *PlanMutation) Where(ps ...predicate.Plan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Plan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Plan).
func (m *PlanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlanMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, plan.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, plan.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, plan.FieldName)
	}
	if m.monthly_limit_bytes != nil {
		fields = append(fields, plan.FieldMonthlyLimitBytes)
	}
	if m.overage_per_gb_cents != nil {
		fields = append(fields, plan.FieldOveragePerGBCents)
	}
	if m.active != nil {
		fields = append(fields, plan.FieldActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case plan.FieldCreatedAt:
		return m.CreatedAt()
	case plan.FieldUpdatedAt:
		return m.UpdatedAt()
	case plan.FieldName:
		return m.Name()
	case plan.FieldMonthlyLimitBytes:
		return m.MonthlyLimitBytes()
	case plan.FieldOveragePerGBCents:
		return m.OveragePerGBCents()
	case plan.FieldActive:
		return m.Active()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case plan.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case plan.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case plan.FieldName:
		return m.OldName(ctx)
	case plan.FieldMonthlyLimitBytes:
		return m.OldMonthlyLimitBytes(ctx)
	case plan.FieldOveragePerGBCents:
		return m.OldOveragePerGBCents(ctx)
	case plan.FieldActive:
		return m.OldActive(ctx)
	}
	return nil, fmt.Errorf("unknown Plan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case plan.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case plan.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case plan.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case plan.FieldMonthlyLimitBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonthlyLimitBytes(v)
		return nil
	case plan.FieldOveragePerGBCents:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOveragePerGBCents(v)
		return nil
	case plan.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	}
	return fmt.Errorf("unknown Plan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlanMutation) AddedFields() []string {
	var fields []string
	if m.addmonthly_limit_bytes != nil {
		fields = append(fields, plan.FieldMonthlyLimitBytes)
	}
	if m.addoverage_per_gb_cents != nil {
		fields = append(fields, plan.FieldOveragePerGBCents)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlanMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case plan.FieldMonthlyLimitBytes:
		return m.AddedMonthlyLimitBytes()
	case plan.FieldOveragePerGBCents:
		return m.AddedOveragePerGBCents()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanMutation) AddField(name string, value ent.Value) error {
	switch name {
	case plan.FieldMonthlyLimitBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMonthlyLimitBytes(v)
		return nil
	case plan.FieldOveragePerGBCents:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOveragePerGBCents(v)
		return nil
	}
	return fmt.Errorf("unknown Plan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlanMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlanMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Plan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlanMutation) ResetField(name string) error {
	switch name {
	case plan.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case plan.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case plan.FieldName:
		m.ResetName()
		return nil
	case plan.FieldMonthlyLimitBytes:
		m.ResetMonthlyLimitBytes()
		return nil
	case plan.FieldOveragePerGBCents:
		m.ResetOveragePerGBCents()
		return nil
	case plan.FieldActive:
		m.ResetActive()
		return nil
	}
	return fmt.Errorf("unknown Plan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlanMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlanMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlanMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlanMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlanMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Plan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlanMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Plan edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *time.Time
	updated_at    *time.Time
	token         *string
	expires_at    *time.Time
	last_used     *time.Time
	is_active     *bool
	user_agent    *string
	ip_address    *string
	clearedFields map[string]struct{}
	owner         *uint32
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Session, error)
	predicates    []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id uint32) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Session entities.
func (m *SessionMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetToken sets the "token" field.
func (m *SessionMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *SessionMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *SessionMutation) ResetToken() {
	m.token = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *SessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *SessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *SessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetLastUsed sets the "last_used" field.
func (m *SessionMutation) SetLastUsed(t time.Time) {
	m.last_used = &t
}

// LastUsed returns the value of the "last_used" field in the mutation.
func (m *SessionMutation) LastUsed() (r time.Time, exists bool) {
	v := m.last_used
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsed returns the old "last_used" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldLastUsed(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsed: %w", err)
	}
	return oldValue.LastUsed, nil
}

// ResetLastUsed resets all changes to the "last_used" field.
func (m *SessionMutation) ResetLastUsed() {
	m.last_used = nil
}

// SetIsActive sets the "is_active" field.
func (m *SessionMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *SessionMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *SessionMutation) ResetIsActive() {
	m.is_active = nil
}

// SetUserAgent sets the "user_agent" field.
func (m *SessionMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *SessionMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *SessionMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[session.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *SessionMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[session.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *SessionMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, session.FieldUserAgent)
}

// SetIPAddress sets the "ip_address" field.
func (m *SessionMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *SessionMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *SessionMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[session.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *SessionMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[session.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *SessionMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, session.FieldIPAddress)
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *SessionMutation) SetOwnerID(id uint32) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *SessionMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *SessionMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *SessionMutation) OwnerID() (id uint32, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) OwnerIDs() (ids []uint32) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *SessionMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, session.FieldUpdatedAt)
	}
	if m.token != nil {
		fields = append(fields, session.FieldToken)
	}
	if m.expires_at != nil {
		fields = append(fields, session.FieldExpiresAt)
	}
	if m.last_used != nil {
		fields = append(fields, session.FieldLastUsed)
	}
	if m.is_active != nil {
		fields = append(fields, session.FieldIsActive)
	}
	if m.user_agent != nil {
		fields = append(fields, session.FieldUserAgent)
	}
	if m.ip_address != nil {
		fields = append(fields, session.FieldIPAddress)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldCreatedAt:
		return m.CreatedAt()
	case session.FieldUpdatedAt:
		return m.UpdatedAt()
	case session.FieldToken:
		return m.Token()
	case session.FieldExpiresAt:
		return m.ExpiresAt()
	case session.FieldLastUsed:
		return m.LastUsed()
	case session.FieldIsActive:
		return m.IsActive()
	case session.FieldUserAgent:
		return m.UserAgent()
	case session.FieldIPAddress:
		return m.IPAddress()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case session.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case session.FieldToken:
		return m.OldToken(ctx)
	case session.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case session.FieldLastUsed:
		return m.OldLastUsed(ctx)
	case session.FieldIsActive:
		return m.OldIsActive(ctx)
	case session.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case session.FieldIPAddress:
		return m.OldIPAddress(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case session.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case session.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case session.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case session.FieldLastUsed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsed(v)
		return nil
	case session.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case session.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case session.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(session.FieldUserAgent) {
		fields = append(fields, session.FieldUserAgent)
	}
	if m.FieldCleared(session.FieldIPAddress) {
		fields = append(fields, session.FieldIPAddress)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	switch name {
	case session.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case session.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	}
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case session.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case session.FieldToken:
		m.ResetToken()
		return nil
	case session.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case session.FieldLastUsed:
		m.ResetLastUsed()
		return nil
	case session.FieldIsActive:
		m.ResetIsActive()
		return nil
	case session.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case session.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, session.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, session.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	case session.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// TokenMutation represents an operation that mutates the Token nodes in the graph.
type TokenMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	name          *string
	token_hash    *string
	created_at    *time.Time
	last_used_at  *time.Time
	expires_at    *time.Time
	revoked_at    *time.Time
	clearedFields map[string]struct{}
	user          *uint32
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Token, error)
	predicates    []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows management of the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for the Token entity.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation {
	m := &TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenID sets the ID field of the mutation.
func withTokenID(id uuid.UUID) tokenOption {
	return func(m *TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Token
		)
		m.oldValue = func(ctx context.Context) (*Token, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption {
	return func(m *TokenMutation) {
		m.oldValue = func(context.Context) (*Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Token entities.
func (m *TokenMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Token.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *TokenMutation) SetUserID(u uint32) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TokenMutation) UserID() (r uint32, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldUserID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TokenMutation) ResetUserID() {
	m.user = nil
}

// SetName sets the "name" field.
func (m *TokenMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TokenMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TokenMutation) ResetName() {
	m.name = nil
}

// SetTokenHash sets the "token_hash" field.
func (m *TokenMutation) SetTokenHash(s string) {
	m.token_hash = &s
}

// TokenHash returns the value of the "token_hash" field in the mutation.
func (m *TokenMutation) TokenHash() (r string, exists bool) {
	v := m.token_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenHash returns the old "token_hash" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldTokenHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenHash: %w", err)
	}
	return oldValue.TokenHash, nil
}

// ResetTokenHash resets all changes to the "token_hash" field.
func (m *TokenMutation) ResetTokenHash() {
	m.token_hash = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *TokenMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *TokenMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldLastUsedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *TokenMutation) ResetLastUsedAt() {
	m.last_used_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *TokenMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *TokenMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *TokenMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetRevokedAt sets the "revoked_at" field.
func (m *TokenMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *TokenMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldRevokedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *TokenMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[token.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *TokenMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[token.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *TokenMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, token.FieldRevokedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *TokenMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[token.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TokenMutation) UserIDs() (ids []uint32) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the TokenMutation builder.
func (m *TokenMutation) Where(ps ...predicate.Token) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Token, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.user != nil {
		fields = append(fields, token.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, token.FieldName)
	}
	if m.token_hash != nil {
		fields = append(fields, token.FieldTokenHash)
	}
	if m.created_at != nil {
		fields = append(fields, token.FieldCreatedAt)
	}
	if m.last_used_at != nil {
		fields = append(fields, token.FieldLastUsedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, token.FieldExpiresAt)
	}
	if m.revoked_at != nil {
		fields = append(fields, token.FieldRevokedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case token.FieldUserID:
		return m.UserID()
	case token.FieldName:
		return m.Name()
	case token.FieldTokenHash:
		return m.TokenHash()
	case token.FieldCreatedAt:
		return m.CreatedAt()
	case token.FieldLastUsedAt:
		return m.LastUsedAt()
	case token.FieldExpiresAt:
		return m.ExpiresAt()
	case token.FieldRevokedAt:
		return m.RevokedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case token.FieldUserID:
		return m.OldUserID(ctx)
	case token.FieldName:
		return m.OldName(ctx)
	case token.FieldTokenHash:
		return m.OldTokenHash(ctx)
	case token.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case token.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	case token.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case token.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Token field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case token.FieldUserID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case token.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case token.FieldTokenHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenHash(v)
		return nil
	case token.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case token.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	case token.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case token.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(token.FieldRevokedAt) {
		fields = append(fields, token.FieldRevokedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error {
	switch name {
	case token.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	}
	return fmt.Errorf("unknown Token nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMutation) ResetField(name string) error {
	switch name {
	case token.FieldUserID:
		m.ResetUserID()
		return nil
	case token.FieldName:
		m.ResetName()
		return nil
	case token.FieldTokenHash:
		m.ResetTokenHash()
		return nil
	case token.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case token.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	case token.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case token.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, token.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case token.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, token.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool {
	switch name {
	case token.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error {
	switch name {
	case token.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Token unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error {
	switch name {
	case token.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Token edge %s", name)
}

// TunnelMutation represents an operation that mutates the Tunnel nodes in the graph.
type TunnelMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	domain         *string
	token          *string
	client_ip      *string
	is_enabled     *bool
	target_port    *int
	addtarget_port *int
	clearedFields  map[string]struct{}
	owner          *uint32
	clearedowner   bool
	done           bool
	oldValue       func(context.Context) (*Tunnel, error)
	predicates     []predicate.Tunnel
}

var _ ent.Mutation = (*TunnelMutation)(nil)

// tunnelOption allows management of the mutation configuration using functional options.
type tunnelOption func(*TunnelMutation)

// newTunnelMutation creates new mutation for the Tunnel entity.
func newTunnelMutation(c config, op Op, opts ...tunnelOption) *TunnelMutation {
	m := &TunnelMutation{
		config:        c,
		op:            op,
		typ:           TypeTunnel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTunnelID sets the ID field of the mutation.
func withTunnelID(id int) tunnelOption {
	return func(m *TunnelMutation) {
		var (
			err   error
			once  sync.Once
			value *Tunnel
		)
		m.oldValue = func(ctx context.Context) (*Tunnel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tunnel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTunnel sets the old Tunnel of the mutation.
func withTunnel(node *Tunnel) tunnelOption {
	return func(m *TunnelMutation) {
		m.oldValue = func(context.Context) (*Tunnel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TunnelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TunnelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TunnelMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TunnelMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tunnel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TunnelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TunnelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tunnel entity.
// If the Tunnel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TunnelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TunnelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TunnelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TunnelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tunnel entity.
// If the Tunnel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TunnelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TunnelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDomain sets the "domain" field.
func (m *TunnelMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *TunnelMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the Tunnel entity.
// If the Tunnel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TunnelMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ResetDomain resets all changes to the "domain" field.
func (m *TunnelMutation) ResetDomain() {
	m.domain = nil
}

// SetToken sets the "token" field.
func (m *TunnelMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *TunnelMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Tunnel entity.
// If the Tunnel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TunnelMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *TunnelMutation) ResetToken() {
	m.token = nil
}

// SetClientIP sets the "client_ip" field.
func (m *TunnelMutation) SetClientIP(s string) {
	m.client_ip = &s
}

// ClientIP returns the value of the "client_ip" field in the mutation.
func (m *TunnelMutation) ClientIP() (r string, exists bool) {
	v := m.client_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldClientIP returns the old "client_ip" field's value of the Tunnel entity.
// If the Tunnel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TunnelMutation) OldClientIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientIP: %w", err)
	}
	return oldValue.ClientIP, nil
}

// ClearClientIP clears the value of the "client_ip" field.
func (m *TunnelMutation) ClearClientIP() {
	m.client_ip = nil
	m.clearedFields[tunnel.FieldClientIP] = struct{}{}
}

// ClientIPCleared returns if the "client_ip" field was cleared in this mutation.
func (m *TunnelMutation) ClientIPCleared() bool {
	_, ok := m.clearedFields[tunnel.FieldClientIP]
	return ok
}

// ResetClientIP resets all changes to the "client_ip" field.
func (m *TunnelMutation) ResetClientIP() {
	m.client_ip = nil
	delete(m.clearedFields, tunnel.FieldClientIP)
}

// SetIsEnabled sets the "is_enabled" field.
func (m *TunnelMutation) SetIsEnabled(b bool) {
	m.is_enabled = &b
}

// IsEnabled returns the value of the "is_enabled" field in the mutation.
func (m *TunnelMutation) IsEnabled() (r bool, exists bool) {
	v := m.is_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEnabled returns the old "is_enabled" field's value of the Tunnel entity.
// If the Tunnel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TunnelMutation) OldIsEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEnabled: %w", err)
	}
	return oldValue.IsEnabled, nil
}

// ResetIsEnabled resets all changes to the "is_enabled" field.
func (m *TunnelMutation) ResetIsEnabled() {
	m.is_enabled = nil
}

// SetTargetPort sets the "target_port" field.
func (m *TunnelMutation) SetTargetPort(i int) {
	m.target_port = &i
	m.addtarget_port = nil
}

// TargetPort returns the value of the "target_port" field in the mutation.
func (m *TunnelMutation) TargetPort() (r int, exists bool) {
	v := m.target_port
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetPort returns the old "target_port" field's value of the Tunnel entity.
// If the Tunnel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TunnelMutation) OldTargetPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetPort: %w", err)
	}
	return oldValue.TargetPort, nil
}

// AddTargetPort adds i to the "target_port" field.
func (m *TunnelMutation) AddTargetPort(i int) {
	if m.addtarget_port != nil {
		*m.addtarget_port += i
	} else {
		m.addtarget_port = &i
	}
}

// AddedTargetPort returns the value that was added to the "target_port" field in this mutation.
func (m *TunnelMutation) AddedTargetPort() (r int, exists bool) {
	v := m.addtarget_port
	if v == nil {
		return
	}
	return *v, true
}

// ResetTargetPort resets all changes to the "target_port" field.
func (m *TunnelMutation) ResetTargetPort() {
	m.target_port = nil
	m.addtarget_port = nil
}

// SetUserID sets the "user_id" field.
func (m *TunnelMutation) SetUserID(u uint32) {
	m.owner = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TunnelMutation) UserID() (r uint32, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Tunnel entity.
// If the Tunnel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TunnelMutation) OldUserID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TunnelMutation) ResetUserID() {
	m.owner = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *TunnelMutation) SetOwnerID(id uint32) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *TunnelMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[tunnel.FieldUserID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *TunnelMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *TunnelMutation) OwnerID() (id uint32, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *TunnelMutation) OwnerIDs() (ids []uint32) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *TunnelMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the TunnelMutation builder.
func (m *TunnelMutation) Where(ps ...predicate.Tunnel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TunnelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TunnelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tunnel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TunnelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TunnelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tunnel).
func (m *TunnelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TunnelMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, tunnel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tunnel.FieldUpdatedAt)
	}
	if m.domain != nil {
		fields = append(fields, tunnel.FieldDomain)
	}
	if m.token != nil {
		fields = append(fields, tunnel.FieldToken)
	}
	if m.client_ip != nil {
		fields = append(fields, tunnel.FieldClientIP)
	}
	if m.is_enabled != nil {
		fields = append(fields, tunnel.FieldIsEnabled)
	}
	if m.target_port != nil {
		fields = append(fields, tunnel.FieldTargetPort)
	}
	if m.owner != nil {
		fields = append(fields, tunnel.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TunnelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tunnel.FieldCreatedAt:
		return m.CreatedAt()
	case tunnel.FieldUpdatedAt:
		return m.UpdatedAt()
	case tunnel.FieldDomain:
		return m.Domain()
	case tunnel.FieldToken:
		return m.Token()
	case tunnel.FieldClientIP:
		return m.ClientIP()
	case tunnel.FieldIsEnabled:
		return m.IsEnabled()
	case tunnel.FieldTargetPort:
		return m.TargetPort()
	case tunnel.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TunnelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tunnel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tunnel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tunnel.FieldDomain:
		return m.OldDomain(ctx)
	case tunnel.FieldToken:
		return m.OldToken(ctx)
	case tunnel.FieldClientIP:
		return m.OldClientIP(ctx)
	case tunnel.FieldIsEnabled:
		return m.OldIsEnabled(ctx)
	case tunnel.FieldTargetPort:
		return m.OldTargetPort(ctx)
	case tunnel.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Tunnel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TunnelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tunnel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tunnel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tunnel.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case tunnel.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case tunnel.FieldClientIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientIP(v)
		return nil
	case tunnel.FieldIsEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEnabled(v)
		return nil
	case tunnel.FieldTargetPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetPort(v)
		return nil
	case tunnel.FieldUserID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Tunnel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TunnelMutation) AddedFields() []string {
	var fields []string
	if m.addtarget_port != nil {
		fields = append(fields, tunnel.FieldTargetPort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TunnelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tunnel.FieldTargetPort:
		return m.AddedTargetPort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TunnelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tunnel.FieldTargetPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTargetPort(v)
		return nil
	}
	return fmt.Errorf("unknown Tunnel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TunnelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tunnel.FieldClientIP) {
		fields = append(fields, tunnel.FieldClientIP)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TunnelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TunnelMutation) ClearField(name string) error {
	switch name {
	case tunnel.FieldClientIP:
		m.ClearClientIP()
		return nil
	}
	return fmt.Errorf("unknown Tunnel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TunnelMutation) ResetField(name string) error {
	switch name {
	case tunnel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tunnel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tunnel.FieldDomain:
		m.ResetDomain()
		return nil
	case tunnel.FieldToken:
		m.ResetToken()
		return nil
	case tunnel.FieldClientIP:
		m.ResetClientIP()
		return nil
	case tunnel.FieldIsEnabled:
		m.ResetIsEnabled()
		return nil
	case tunnel.FieldTargetPort:
		m.ResetTargetPort()
		return nil
	case tunnel.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Tunnel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TunnelMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, tunnel.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TunnelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tunnel.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TunnelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TunnelMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TunnelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, tunnel.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TunnelMutation) EdgeCleared(name string) bool {
	switch name {
	case tunnel.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TunnelMutation) ClearEdge(name string) error {
	switch name {
	case tunnel.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Tunnel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TunnelMutation) ResetEdge(name string) error {
	switch name {
	case tunnel.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Tunnel edge %s", name)
}

// UsageMutation represents an operation that mutates the Usage nodes in the graph.
type UsageMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	period_start  *time.Time
	user_id       *uint32
	adduser_id    *int32
	tunnel_id     *uint32
	addtunnel_id  *int32
	domain        *string
	bytes_in      *int64
	addbytes_in   *int64
	bytes_out     *int64
	addbytes_out  *int64
	requests      *int64
	addrequests   *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Usage, error)
	predicates    []predicate.Usage
}

var _ ent.Mutation = (*UsageMutation)(nil)

// usageOption allows management of the mutation configuration using functional options.
type usageOption func(*UsageMutation)

// newUsageMutation creates new mutation for the Usage entity.
func newUsageMutation(c config, op Op, opts ...usageOption) *UsageMutation {
	m := &UsageMutation{
		config:        c,
		op:            op,
		typ:           TypeUsage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUsageID sets the ID field of the mutation.
func withUsageID(id int) usageOption {
	return func(m *UsageMutation) {
		var (
			err   error
			once  sync.Once
			value *Usage
		)
		m.oldValue = func(ctx context.Context) (*Usage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Usage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUsage sets the old Usage of the mutation.
func withUsage(node *Usage) usageOption {
	return func(m *UsageMutation) {
		m.oldValue = func(context.Context) (*Usage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UsageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UsageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UsageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UsageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Usage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UsageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UsageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Usage entity.
// If the Usage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UsageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UsageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UsageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Usage entity.
// If the Usage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UsageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPeriodStart sets the "period_start" field.
func (m *UsageMutation) SetPeriodStart(t time.Time) {
	m.period_start = &t
}

// PeriodStart returns the value of the "period_start" field in the mutation.
func (m *UsageMutation) PeriodStart() (r time.Time, exists bool) {
	v := m.period_start
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriodStart returns the old "period_start" field's value of the Usage entity.
// If the Usage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageMutation) OldPeriodStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriodStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriodStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriodStart: %w", err)
	}
	return oldValue.PeriodStart, nil
}

// ResetPeriodStart resets all changes to the "period_start" field.
func (m *UsageMutation) ResetPeriodStart() {
	m.period_start = nil
}

// SetUserID sets the "user_id" field.
func (m *UsageMutation) SetUserID(u uint32) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UsageMutation) UserID() (r uint32, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Usage entity.
// If the Usage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageMutation) OldUserID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *UsageMutation) AddUserID(u int32) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UsageMutation) AddedUserID() (r int32, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UsageMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetTunnelID sets the "tunnel_id" field.
func (m *UsageMutation) SetTunnelID(u uint32) {
	m.tunnel_id = &u
	m.addtunnel_id = nil
}

// TunnelID returns the value of the "tunnel_id" field in the mutation.
func (m *UsageMutation) TunnelID() (r uint32, exists bool) {
	v := m.tunnel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTunnelID returns the old "tunnel_id" field's value of the Usage entity.
// If the Usage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageMutation) OldTunnelID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTunnelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTunnelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTunnelID: %w", err)
	}
	return oldValue.TunnelID, nil
}

// AddTunnelID adds u to the "tunnel_id" field.
func (m *UsageMutation) AddTunnelID(u int32) {
	if m.addtunnel_id != nil {
		*m.addtunnel_id += u
	} else {
		m.addtunnel_id = &u
	}
}

// AddedTunnelID returns the value that was added to the "tunnel_id" field in this mutation.
func (m *UsageMutation) AddedTunnelID() (r int32, exists bool) {
	v := m.addtunnel_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTunnelID clears the value of the "tunnel_id" field.
func (m *UsageMutation) ClearTunnelID() {
	m.tunnel_id = nil
	m.addtunnel_id = nil
	m.clearedFields[usage.FieldTunnelID] = struct{}{}
}

// TunnelIDCleared returns if the "tunnel_id" field was cleared in this mutation.
func (m *UsageMutation) TunnelIDCleared() bool {
	_, ok := m.clearedFields[usage.FieldTunnelID]
	return ok
}

// ResetTunnelID resets all changes to the "tunnel_id" field.
func (m *UsageMutation) ResetTunnelID() {
	m.tunnel_id = nil
	m.addtunnel_id = nil
	delete(m.clearedFields, usage.FieldTunnelID)
}

// SetDomain sets the "domain" field.
func (m *UsageMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *UsageMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the Usage entity.
// If the Usage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ResetDomain resets all changes to the "domain" field.
func (m *UsageMutation) ResetDomain() {
	m.domain = nil
}

// SetBytesIn sets the "bytes_in" field.
func (m *UsageMutation) SetBytesIn(i int64) {
	m.bytes_in = &i
	m.addbytes_in = nil
}

// BytesIn returns the value of the "bytes_in" field in the mutation.
func (m *UsageMutation) BytesIn() (r int64, exists bool) {
	v := m.bytes_in
	if v == nil {
		return
	}
	return *v, true
}

// OldBytesIn returns the old "bytes_in" field's value of the Usage entity.
// If the Usage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageMutation) OldBytesIn(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBytesIn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBytesIn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBytesIn: %w", err)
	}
	return oldValue.BytesIn, nil
}

// AddBytesIn adds i to the "bytes_in" field.
func (m *UsageMutation) AddBytesIn(i int64) {
	if m.addbytes_in != nil {
		*m.addbytes_in += i
	} else {
		m.addbytes_in = &i
	}
}

// AddedBytesIn returns the value that was added to the "bytes_in" field in this mutation.
func (m *UsageMutation) AddedBytesIn() (r int64, exists bool) {
	v := m.addbytes_in
	if v == nil {
		return
	}
	return *v, true
}

// ResetBytesIn resets all changes to the "bytes_in" field.
func (m *UsageMutation) ResetBytesIn() {
	m.bytes_in = nil
	m.addbytes_in = nil
}

// SetBytesOut sets the "bytes_out" field.
func (m *UsageMutation) SetBytesOut(i int64) {
	m.bytes_out = &i
	m.addbytes_out = nil
}

// BytesOut returns the value of the "bytes_out" field in the mutation.
func (m *UsageMutation) BytesOut() (r int64, exists bool) {
	v := m.bytes_out
	if v == nil {
		return
	}
	return *v, true
}

// OldBytesOut returns the old "bytes_out" field's value of the Usage entity.
// If the Usage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageMutation) OldBytesOut(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBytesOut is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBytesOut requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBytesOut: %w", err)
	}
	return oldValue.BytesOut, nil
}

// AddBytesOut adds i to the "bytes_out" field.
func (m *UsageMutation) AddBytesOut(i int64) {
	if m.addbytes_out != nil {
		*m.addbytes_out += i
	} else {
		m.addbytes_out = &i
	}
}

// AddedBytesOut returns the value that was added to the "bytes_out" field in this mutation.
func (m *UsageMutation) AddedBytesOut() (r int64, exists bool) {
	v := m.addbytes_out
	if v == nil {
		return
	}
	return *v, true
}

// ResetBytesOut resets all changes to the "bytes_out" field.
func (m *UsageMutation) ResetBytesOut() {
	m.bytes_out = nil
	m.addbytes_out = nil
}

// SetRequests sets the "requests" field.
func (m *UsageMutation) SetRequests(i int64) {
	m.requests = &i
	m.addrequests = nil
}

// Requests returns the value of the "requests" field in the mutation.
func (m *UsageMutation) Requests() (r int64, exists bool) {
	v := m.requests
	if v == nil {
		return
	}
	return *v, true
}

// OldRequests returns the old "requests" field's value of the Usage entity.
// If the Usage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageMutation) OldRequests(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequests is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequests requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequests: %w", err)
	}
	return oldValue.Requests, nil
}

// AddRequests adds i to the "requests" field.
func (m *UsageMutation) AddRequests(i int64) {
	if m.addrequests != nil {
		*m.addrequests += i
	} else {
		m.addrequests = &i
	}
}

// AddedRequests returns the value that was added to the "requests" field in this mutation.
func (m *UsageMutation) AddedRequests() (r int64, exists bool) {
	v := m.addrequests
	if v == nil {
		return
	}
	return *v, true
}

// ResetRequests resets all changes to the "requests" field.
func (m *UsageMutation) ResetRequests() {
	m.requests = nil
	m.addrequests = nil
}

// Where appends a list predicates to the UsageMutation builder.
func (m *UsageMutation) Where(ps ...predicate.Usage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UsageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UsageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Usage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UsageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UsageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Usage).
func (m *UsageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UsageMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, usage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usage.FieldUpdatedAt)
	}
	if m.period_start != nil {
		fields = append(fields, usage.FieldPeriodStart)
	}
	if m.user_id != nil {
		fields = append(fields, usage.FieldUserID)
	}
	if m.tunnel_id != nil {
		fields = append(fields, usage.FieldTunnelID)
	}
	if m.domain != nil {
		fields = append(fields, usage.FieldDomain)
	}
	if m.bytes_in != nil {
		fields = append(fields, usage.FieldBytesIn)
	}
	if m.bytes_out != nil {
		fields = append(fields, usage.FieldBytesOut)
	}
	if m.requests != nil {
		fields = append(fields, usage.FieldRequests)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UsageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usage.FieldCreatedAt:
		return m.CreatedAt()
	case usage.FieldUpdatedAt:
		return m.UpdatedAt()
	case usage.FieldPeriodStart:
		return m.PeriodStart()
	case usage.FieldUserID:
		return m.UserID()
	case usage.FieldTunnelID:
		return m.TunnelID()
	case usage.FieldDomain:
		return m.Domain()
	case usage.FieldBytesIn:
		return m.BytesIn()
	case usage.FieldBytesOut:
		return m.BytesOut()
	case usage.FieldRequests:
		return m.Requests()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UsageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usage.FieldPeriodStart:
		return m.OldPeriodStart(ctx)
	case usage.FieldUserID:
		return m.OldUserID(ctx)
	case usage.FieldTunnelID:
		return m.OldTunnelID(ctx)
	case usage.FieldDomain:
		return m.OldDomain(ctx)
	case usage.FieldBytesIn:
		return m.OldBytesIn(ctx)
	case usage.FieldBytesOut:
		return m.OldBytesOut(ctx)
	case usage.FieldRequests:
		return m.OldRequests(ctx)
	}
	return nil, fmt.Errorf("unknown Usage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usage.FieldPeriodStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriodStart(v)
		return nil
	case usage.FieldUserID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usage.FieldTunnelID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTunnelID(v)
		return nil
	case usage.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case usage.FieldBytesIn:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBytesIn(v)
		return nil
	case usage.FieldBytesOut:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBytesOut(v)
		return nil
	case usage.FieldRequests:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequests(v)
		return nil
	}
	return fmt.Errorf("unknown Usage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UsageMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, usage.FieldUserID)
	}
	if m.addtunnel_id != nil {
		fields = append(fields, usage.FieldTunnelID)
	}
	if m.addbytes_in != nil {
		fields = append(fields, usage.FieldBytesIn)
	}
	if m.addbytes_out != nil {
		fields = append(fields, usage.FieldBytesOut)
	}
	if m.addrequests != nil {
		fields = append(fields, usage.FieldRequests)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UsageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usage.FieldUserID:
		return m.AddedUserID()
	case usage.FieldTunnelID:
		return m.AddedTunnelID()
	case usage.FieldBytesIn:
		return m.AddedBytesIn()
	case usage.FieldBytesOut:
		return m.AddedBytesOut()
	case usage.FieldRequests:
		return m.AddedRequests()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usage.FieldUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case usage.FieldTunnelID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTunnelID(v)
		return nil
	case usage.FieldBytesIn:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBytesIn(v)
		return nil
	case usage.FieldBytesOut:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBytesOut(v)
		return nil
	case usage.FieldRequests:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRequests(v)
		return nil
	}
	return fmt.Errorf("unknown Usage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UsageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usage.FieldTunnelID) {
		fields = append(fields, usage.FieldTunnelID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UsageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UsageMutation) ClearField(name string) error {
	switch name {
	case usage.FieldTunnelID:
		m.ClearTunnelID()
		return nil
	}
	return fmt.Errorf("unknown Usage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UsageMutation) ResetField(name string) error {
	switch name {
	case usage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usage.FieldPeriodStart:
		m.ResetPeriodStart()
		return nil
	case usage.FieldUserID:
		m.ResetUserID()
		return nil
	case usage.FieldTunnelID:
		m.ResetTunnelID()
		return nil
	case usage.FieldDomain:
		m.ResetDomain()
		return nil
	case usage.FieldBytesIn:
		m.ResetBytesIn()
		return nil
	case usage.FieldBytesOut:
		m.ResetBytesOut()
		return nil
	case usage.FieldRequests:
		m.ResetRequests()
		return nil
	}
	return fmt.Errorf("unknown Usage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UsageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UsageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UsageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UsageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UsageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UsageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UsageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Usage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UsageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Usage edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op              Op
	typ             string
	id              *uint32
	created_at      *time.Time
	updated_at      *time.Time
	firebase_uid    *string
	email           *string
	name            *string
	role            *string
	is_active       *bool
	last_login      *time.Time
	last_login_ip   *string
	last_activity   *time.Time
	plan_name       *string
	clearedFields   map[string]struct{}
	sessions        map[uint32]struct{}
	removedsessions map[uint32]struct{}
	clearedsessions bool
	tokens          map[uuid.UUID]struct{}
	removedtokens   map[uuid.UUID]struct{}
	clearedtokens   bool
	tunnels         map[int]struct{}
	removedtunnels  map[int]struct{}
	clearedtunnels  bool
	done            bool
	oldValue        func(context.Context) (*User, error)
	predicates      []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uint32) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetFirebaseUID sets the "firebase_uid" field.
func (m *UserMutation) SetFirebaseUID(s string) {
	m.firebase_uid = &s
}

// FirebaseUID returns the value of the "firebase_uid" field in the mutation.
func (m *UserMutation) FirebaseUID() (r string, exists bool) {
	v := m.firebase_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldFirebaseUID returns the old "firebase_uid" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirebaseUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirebaseUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirebaseUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirebaseUID: %w", err)
	}
	return oldValue.FirebaseUID, nil
}

// ResetFirebaseUID resets all changes to the "firebase_uid" field.
func (m *UserMutation) ResetFirebaseUID() {
	m.firebase_uid = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UserMutation) ClearName() {
	m.name = nil
	m.clearedFields[user.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UserMutation) NameCleared() bool {
	_, ok := m.clearedFields[user.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, user.FieldName)
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetIsActive sets the "is_active" field.
func (m *UserMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *UserMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *UserMutation) ResetIsActive() {
	m.is_active = nil
}

// SetLastLogin sets the "last_login" field.
func (m *UserMutation) SetLastLogin(t time.Time) {
	m.last_login = &t
}

// LastLogin returns the value of the "last_login" field in the mutation.
func (m *UserMutation) LastLogin() (r time.Time, exists bool) {
	v := m.last_login
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLogin returns the old "last_login" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLogin(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLogin: %w", err)
	}
	return oldValue.LastLogin, nil
}

// ClearLastLogin clears the value of the "last_login" field.
func (m *UserMutation) ClearLastLogin() {
	m.last_login = nil
	m.clearedFields[user.FieldLastLogin] = struct{}{}
}

// LastLoginCleared returns if the "last_login" field was cleared in this mutation.
func (m *UserMutation) LastLoginCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLogin]
	return ok
}

// ResetLastLogin resets all changes to the "last_login" field.
func (m *UserMutation) ResetLastLogin() {
	m.last_login = nil
	delete(m.clearedFields, user.FieldLastLogin)
}

// SetLastLoginIP sets the "last_login_ip" field.
func (m *UserMutation) SetLastLoginIP(s string) {
	m.last_login_ip = &s
}

// LastLoginIP returns the value of the "last_login_ip" field in the mutation.
func (m *UserMutation) LastLoginIP() (r string, exists bool) {
	v := m.last_login_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginIP returns the old "last_login_ip" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginIP(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginIP: %w", err)
	}
	return oldValue.LastLoginIP, nil
}

// ClearLastLoginIP clears the value of the "last_login_ip" field.
func (m *UserMutation) ClearLastLoginIP() {
	m.last_login_ip = nil
	m.clearedFields[user.FieldLastLoginIP] = struct{}{}
}

// LastLoginIPCleared returns if the "last_login_ip" field was cleared in this mutation.
func (m *UserMutation) LastLoginIPCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginIP]
	return ok
}

// ResetLastLoginIP resets all changes to the "last_login_ip" field.
func (m *UserMutation) ResetLastLoginIP() {
	m.last_login_ip = nil
	delete(m.clearedFields, user.FieldLastLoginIP)
}

// SetLastActivity sets the "last_activity" field.
func (m *UserMutation) SetLastActivity(t time.Time) {
	m.last_activity = &t
}

// LastActivity returns the value of the "last_activity" field in the mutation.
func (m *UserMutation) LastActivity() (r time.Time, exists bool) {
	v := m.last_activity
	if v == nil {
		return
	}
	return *v, true
}

// OldLastActivity returns the old "last_activity" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastActivity(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastActivity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastActivity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastActivity: %w", err)
	}
	return oldValue.LastActivity, nil
}

// ClearLastActivity clears the value of the "last_activity" field.
func (m *UserMutation) ClearLastActivity() {
	m.last_activity = nil
	m.clearedFields[user.FieldLastActivity] = struct{}{}
}

// LastActivityCleared returns if the "last_activity" field was cleared in this mutation.
func (m *UserMutation) LastActivityCleared() bool {
	_, ok := m.clearedFields[user.FieldLastActivity]
	return ok
}

// ResetLastActivity resets all changes to the "last_activity" field.
func (m *UserMutation) ResetLastActivity() {
	m.last_activity = nil
	delete(m.clearedFields, user.FieldLastActivity)
}

// SetPlanName sets the "plan_name" field.
func (m *UserMutation) SetPlanName(s string) {
	m.plan_name = &s
}

// PlanName returns the value of the "plan_name" field in the mutation.
func (m *UserMutation) PlanName() (r string, exists bool) {
	v := m.plan_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanName returns the old "plan_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPlanName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanName: %w", err)
	}
	return oldValue.PlanName, nil
}

// ClearPlanName clears the value of the "plan_name" field.
func (m *UserMutation) ClearPlanName() {
	m.plan_name = nil
	m.clearedFields[user.FieldPlanName] = struct{}{}
}

// PlanNameCleared returns if the "plan_name" field was cleared in this mutation.
func (m *UserMutation) PlanNameCleared() bool {
	_, ok := m.clearedFields[user.FieldPlanName]
	return ok
}

// ResetPlanName resets all changes to the "plan_name" field.
func (m *UserMutation) ResetPlanName() {
	m.plan_name = nil
	delete(m.clearedFields, user.FieldPlanName)
}

// AddSessionIDs adds the "sessions" edge to the Session entity by ids.
func (m *UserMutation) AddSessionIDs(ids ...uint32) {
	if m.sessions == nil {
		m.sessions = make(map[uint32]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the Session entity.
func (m *UserMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the Session entity was cleared.
func (m *UserMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the Session entity by IDs.
func (m *UserMutation) RemoveSessionIDs(ids ...uint32) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the Session entity.
func (m *UserMutation) RemovedSessionsIDs() (ids []uint32) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *UserMutation) SessionsIDs() (ids []uint32) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *UserMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// AddTokenIDs adds the "tokens" edge to the Token entity by ids.
func (m *UserMutation) AddTokenIDs(ids ...uuid.UUID) {
	if m.tokens == nil {
		m.tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tokens[ids[i]] = struct{}{}
	}
}

// ClearTokens clears the "tokens" edge to the Token entity.
func (m *UserMutation) ClearTokens() {
	m.clearedtokens = true
}

// TokensCleared reports if the "tokens" edge to the Token entity was cleared.
func (m *UserMutation) TokensCleared() bool {
	return m.clearedtokens
}

// RemoveTokenIDs removes the "tokens" edge to the Token entity by IDs.
func (m *UserMutation) RemoveTokenIDs(ids ...uuid.UUID) {
	if m.removedtokens == nil {
		m.removedtokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tokens, ids[i])
		m.removedtokens[ids[i]] = struct{}{}
	}
}

// RemovedTokens returns the removed IDs of the "tokens" edge to the Token entity.
func (m *UserMutation) RemovedTokensIDs() (ids []uuid.UUID) {
	for id := range m.removedtokens {
		ids = append(ids, id)
	}
	return
}

// TokensIDs returns the "tokens" edge IDs in the mutation.
func (m *UserMutation) TokensIDs() (ids []uuid.UUID) {
	for id := range m.tokens {
		ids = append(ids, id)
	}
	return
}

// ResetTokens resets all changes to the "tokens" edge.
func (m *UserMutation) ResetTokens() {
	m.tokens = nil
	m.clearedtokens = false
	m.removedtokens = nil
}

// AddTunnelIDs adds the "tunnels" edge to the Tunnel entity by ids.
func (m *UserMutation) AddTunnelIDs(ids ...int) {
	if m.tunnels == nil {
		m.tunnels = make(map[int]struct{})
	}
	for i := range ids {
		m.tunnels[ids[i]] = struct{}{}
	}
}

// ClearTunnels clears the "tunnels" edge to the Tunnel entity.
func (m *UserMutation) ClearTunnels() {
	m.clearedtunnels = true
}

// TunnelsCleared reports if the "tunnels" edge to the Tunnel entity was cleared.
func (m *UserMutation) TunnelsCleared() bool {
	return m.clearedtunnels
}

// RemoveTunnelIDs removes the "tunnels" edge to the Tunnel entity by IDs.
func (m *UserMutation) RemoveTunnelIDs(ids ...int) {
	if m.removedtunnels == nil {
		m.removedtunnels = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tunnels, ids[i])
		m.removedtunnels[ids[i]] = struct{}{}
	}
}

// RemovedTunnels returns the removed IDs of the "tunnels" edge to the Tunnel entity.
func (m *UserMutation) RemovedTunnelsIDs() (ids []int) {
	for id := range m.removedtunnels {
		ids = append(ids, id)
	}
	return
}

// TunnelsIDs returns the "tunnels" edge IDs in the mutation.
func (m *UserMutation) TunnelsIDs() (ids []int) {
	for id := range m.tunnels {
		ids = append(ids, id)
	}
	return
}

// ResetTunnels resets all changes to the "tunnels" edge.
func (m *UserMutation) ResetTunnels() {
	m.tunnels = nil
	m.clearedtunnels = false
	m.removedtunnels = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.firebase_uid != nil {
		fields = append(fields, user.FieldFirebaseUID)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.is_active != nil {
		fields = append(fields, user.FieldIsActive)
	}
	if m.last_login != nil {
		fields = append(fields, user.FieldLastLogin)
	}
	if m.last_login_ip != nil {
		fields = append(fields, user.FieldLastLoginIP)
	}
	if m.last_activity != nil {
		fields = append(fields, user.FieldLastActivity)
	}
	if m.plan_name != nil {
		fields = append(fields, user.FieldPlanName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldFirebaseUID:
		return m.FirebaseUID()
	case user.FieldEmail:
		return m.Email()
	case user.FieldName:
		return m.Name()
	case user.FieldRole:
		return m.Role()
	case user.FieldIsActive:
		return m.IsActive()
	case user.FieldLastLogin:
		return m.LastLogin()
	case user.FieldLastLoginIP:
		return m.LastLoginIP()
	case user.FieldLastActivity:
		return m.LastActivity()
	case user.FieldPlanName:
		return m.PlanName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldFirebaseUID:
		return m.OldFirebaseUID(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldIsActive:
		return m.OldIsActive(ctx)
	case user.FieldLastLogin:
		return m.OldLastLogin(ctx)
	case user.FieldLastLoginIP:
		return m.OldLastLoginIP(ctx)
	case user.FieldLastActivity:
		return m.OldLastActivity(ctx)
	case user.FieldPlanName:
		return m.OldPlanName(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldFirebaseUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirebaseUID(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case user.FieldLastLogin:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLogin(v)
		return nil
	case user.FieldLastLoginIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginIP(v)
		return nil
	case user.FieldLastActivity:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastActivity(v)
		return nil
	case user.FieldPlanName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanName(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldName) {
		fields = append(fields, user.FieldName)
	}
	if m.FieldCleared(user.FieldLastLogin) {
		fields = append(fields, user.FieldLastLogin)
	}
	if m.FieldCleared(user.FieldLastLoginIP) {
		fields = append(fields, user.FieldLastLoginIP)
	}
	if m.FieldCleared(user.FieldLastActivity) {
		fields = append(fields, user.FieldLastActivity)
	}
	if m.FieldCleared(user.FieldPlanName) {
		fields = append(fields, user.FieldPlanName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldName:
		m.ClearName()
		return nil
	case user.FieldLastLogin:
		m.ClearLastLogin()
		return nil
	case user.FieldLastLoginIP:
		m.ClearLastLoginIP()
		return nil
	case user.FieldLastActivity:
		m.ClearLastActivity()
		return nil
	case user.FieldPlanName:
		m.ClearPlanName()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldFirebaseUID:
		m.ResetFirebaseUID()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldIsActive:
		m.ResetIsActive()
		return nil
	case user.FieldLastLogin:
		m.ResetLastLogin()
		return nil
	case user.FieldLastLoginIP:
		m.ResetLastLoginIP()
		return nil
	case user.FieldLastActivity:
		m.ResetLastActivity()
		return nil
	case user.FieldPlanName:
		m.ResetPlanName()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.sessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.tokens != nil {
		edges = append(edges, user.EdgeTokens)
	}
	if m.tunnels != nil {
		edges = append(edges, user.EdgeTunnels)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.tokens))
		for id := range m.tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTunnels:
		ids := make([]ent.Value, 0, len(m.tunnels))
		for id := range m.tunnels {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedsessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.removedtokens != nil {
		edges = append(edges, user.EdgeTokens)
	}
	if m.removedtunnels != nil {
		edges = append(edges, user.EdgeTunnels)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.removedtokens))
		for id := range m.removedtokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTunnels:
		ids := make([]ent.Value, 0, len(m.removedtunnels))
		for id := range m.removedtunnels {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedsessions {
		edges = append(edges, user.EdgeSessions)
	}
	if m.clearedtokens {
		edges = append(edges, user.EdgeTokens)
	}
	if m.clearedtunnels {
		edges = append(edges, user.EdgeTunnels)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeSessions:
		return m.clearedsessions
	case user.EdgeTokens:
		return m.clearedtokens
	case user.EdgeTunnels:
		return m.clearedtunnels
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeSessions:
		m.ResetSessions()
		return nil
	case user.EdgeTokens:
		m.ResetTokens()
		return nil
	case user.EdgeTunnels:
		m.ResetTunnels()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
