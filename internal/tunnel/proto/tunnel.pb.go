// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.9
// 	protoc        v5.29.3
// source: tunnel.proto

package proto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// TunnelType enum for different tunnel types
type TunnelType int32

const (
	TunnelType_TUNNEL_TYPE_UNKNOWN TunnelType = 0
	TunnelType_TUNNEL_TYPE_TCP     TunnelType = 1 // TCP tunnel for WebSocket traffic
	TunnelType_TUNNEL_TYPE_GRPC    TunnelType = 2 // gRPC tunnel for HTTP traffic
	TunnelType_TUNNEL_TYPE_HYBRID  TunnelType = 3 // Both tunnels
)

// Enum value maps for TunnelType.
var (
	TunnelType_name = map[int32]string{
		0: "TUNNEL_TYPE_UNKNOWN",
		1: "TUNNEL_TYPE_TCP",
		2: "TUNNEL_TYPE_GRPC",
		3: "TUNNEL_TYPE_HYBRID",
	}
	TunnelType_value = map[string]int32{
		"TUNNEL_TYPE_UNKNOWN": 0,
		"TUNNEL_TYPE_TCP":     1,
		"TUNNEL_TYPE_GRPC":    2,
		"TUNNEL_TYPE_HYBRID":  3,
	}
)

func (x TunnelType) Enum() *TunnelType {
	p := new(TunnelType)
	*p = x
	return p
}

func (x TunnelType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TunnelType) Descriptor() protoreflect.EnumDescriptor {
	return file_tunnel_proto_enumTypes[0].Descriptor()
}

func (TunnelType) Type() protoreflect.EnumType {
	return &file_tunnel_proto_enumTypes[0]
}

func (x TunnelType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TunnelType.Descriptor instead.
func (TunnelType) EnumDescriptor() ([]byte, []int) {
	return file_tunnel_proto_rawDescGZIP(), []int{0}
}

// TunnelState enum
type TunnelState int32

const (
	TunnelState_TUNNEL_STATE_UNKNOWN        TunnelState = 0
	TunnelState_TUNNEL_STATE_CONNECTING     TunnelState = 1
	TunnelState_TUNNEL_STATE_CONNECTED      TunnelState = 2
	TunnelState_TUNNEL_STATE_AUTHENTICATING TunnelState = 3
	TunnelState_TUNNEL_STATE_ACTIVE         TunnelState = 4
	TunnelState_TUNNEL_STATE_DISCONNECTING  TunnelState = 5
	TunnelState_TUNNEL_STATE_DISCONNECTED   TunnelState = 6
	TunnelState_TUNNEL_STATE_ERROR          TunnelState = 7
)

// Enum value maps for TunnelState.
var (
	TunnelState_name = map[int32]string{
		0: "TUNNEL_STATE_UNKNOWN",
		1: "TUNNEL_STATE_CONNECTING",
		2: "TUNNEL_STATE_CONNECTED",
		3: "TUNNEL_STATE_AUTHENTICATING",
		4: "TUNNEL_STATE_ACTIVE",
		5: "TUNNEL_STATE_DISCONNECTING",
		6: "TUNNEL_STATE_DISCONNECTED",
		7: "TUNNEL_STATE_ERROR",
	}
	TunnelState_value = map[string]int32{
		"TUNNEL_STATE_UNKNOWN":        0,
		"TUNNEL_STATE_CONNECTING":     1,
		"TUNNEL_STATE_CONNECTED":      2,
		"TUNNEL_STATE_AUTHENTICATING": 3,
		"TUNNEL_STATE_ACTIVE":         4,
		"TUNNEL_STATE_DISCONNECTING":  5,
		"TUNNEL_STATE_DISCONNECTED":   6,
		"TUNNEL_STATE_ERROR":          7,
	}
)

func (x TunnelState) Enum() *TunnelState {
	p := new(TunnelState)
	*p = x
	return p
}

func (x TunnelState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TunnelState) Descriptor() protoreflect.EnumDescriptor {
	return file_tunnel_proto_enumTypes[1].Descriptor()
}

func (TunnelState) Type() protoreflect.EnumType {
	return &file_tunnel_proto_enumTypes[1]
}

func (x TunnelState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TunnelState.Descriptor instead.
func (TunnelState) EnumDescriptor() ([]byte, []int) {
	return file_tunnel_proto_rawDescGZIP(), []int{1}
}

// Health status enum
type HealthStatus int32

const (
	HealthStatus_HEALTH_STATUS_UNKNOWN         HealthStatus = 0
	HealthStatus_HEALTH_STATUS_SERVING         HealthStatus = 1
	HealthStatus_HEALTH_STATUS_NOT_SERVING     HealthStatus = 2
	HealthStatus_HEALTH_STATUS_SERVICE_UNKNOWN HealthStatus = 3
)

// Enum value maps for HealthStatus.
var (
	HealthStatus_name = map[int32]string{
		0: "HEALTH_STATUS_UNKNOWN",
		1: "HEALTH_STATUS_SERVING",
		2: "HEALTH_STATUS_NOT_SERVING",
		3: "HEALTH_STATUS_SERVICE_UNKNOWN",
	}
	HealthStatus_value = map[string]int32{
		"HEALTH_STATUS_UNKNOWN":         0,
		"HEALTH_STATUS_SERVING":         1,
		"HEALTH_STATUS_NOT_SERVING":     2,
		"HEALTH_STATUS_SERVICE_UNKNOWN": 3,
	}
)

func (x HealthStatus) Enum() *HealthStatus {
	p := new(HealthStatus)
	*p = x
	return p
}

func (x HealthStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (HealthStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_tunnel_proto_enumTypes[2].Descriptor()
}

func (HealthStatus) Type() protoreflect.EnumType {
	return &file_tunnel_proto_enumTypes[2]
}

func (x HealthStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use HealthStatus.Descriptor instead.
func (HealthStatus) EnumDescriptor() ([]byte, []int) {
	return file_tunnel_proto_rawDescGZIP(), []int{2}
}

// Request type classification
type RequestType int32

const (
	RequestType_REQUEST_TYPE_UNKNOWN    RequestType = 0
	RequestType_REQUEST_TYPE_API        RequestType = 1
	RequestType_REQUEST_TYPE_MEDIA      RequestType = 2
	RequestType_REQUEST_TYPE_STATIC     RequestType = 3
	RequestType_REQUEST_TYPE_LARGE_FILE RequestType = 4
)

// Enum value maps for RequestType.
var (
	RequestType_name = map[int32]string{
		0: "REQUEST_TYPE_UNKNOWN",
		1: "REQUEST_TYPE_API",
		2: "REQUEST_TYPE_MEDIA",
		3: "REQUEST_TYPE_STATIC",
		4: "REQUEST_TYPE_LARGE_FILE",
	}
	RequestType_value = map[string]int32{
		"REQUEST_TYPE_UNKNOWN":    0,
		"REQUEST_TYPE_API":        1,
		"REQUEST_TYPE_MEDIA":      2,
		"REQUEST_TYPE_STATIC":     3,
		"REQUEST_TYPE_LARGE_FILE": 4,
	}
)

func (x RequestType) Enum() *RequestType {
	p := new(RequestType)
	*p = x
	return p
}

func (x RequestType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RequestType) Descriptor() protoreflect.EnumDescriptor {
	return file_tunnel_proto_enumTypes[3].Descriptor()
}

func (RequestType) Type() protoreflect.EnumType {
	return &file_tunnel_proto_enumTypes[3]
}

func (x RequestType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use RequestType.Descriptor instead.
func (RequestType) EnumDescriptor() ([]byte, []int) {
	return file_tunnel_proto_rawDescGZIP(), []int{3}
}

// Request priority for QoS
type Priority int32

const (
	Priority_PRIORITY_UNKNOWN  Priority = 0
	Priority_PRIORITY_LOW      Priority = 1
	Priority_PRIORITY_NORMAL   Priority = 2
	Priority_PRIORITY_HIGH     Priority = 3
	Priority_PRIORITY_CRITICAL Priority = 4
)

// Enum value maps for Priority.
var (
	Priority_name = map[int32]string{
		0: "PRIORITY_UNKNOWN",
		1: "PRIORITY_LOW",
		2: "PRIORITY_NORMAL",
		3: "PRIORITY_HIGH",
		4: "PRIORITY_CRITICAL",
	}
	Priority_value = map[string]int32{
		"PRIORITY_UNKNOWN":  0,
		"PRIORITY_LOW":      1,
		"PRIORITY_NORMAL":   2,
		"PRIORITY_HIGH":     3,
		"PRIORITY_CRITICAL": 4,
	}
)

func (x Priority) Enum() *Priority {
	p := new(Priority)
	*p = x
	return p
}

func (x Priority) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Priority) Descriptor() protoreflect.EnumDescriptor {
	return file_tunnel_proto_enumTypes[4].Descriptor()
}

func (Priority) Type() protoreflect.EnumType {
	return &file_tunnel_proto_enumTypes[4]
}

func (x Priority) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Priority.Descriptor instead.
func (Priority) EnumDescriptor() ([]byte, []int) {
	return file_tunnel_proto_rawDescGZIP(), []int{4}
}

// Cache status for optimization
type CacheStatus int32

const (
	CacheStatus_CACHE_STATUS_UNKNOWN CacheStatus = 0
	CacheStatus_CACHE_STATUS_HIT     CacheStatus = 1
	CacheStatus_CACHE_STATUS_MISS    CacheStatus = 2
	CacheStatus_CACHE_STATUS_STALE   CacheStatus = 3
	CacheStatus_CACHE_STATUS_BYPASS  CacheStatus = 4
)

// Enum value maps for CacheStatus.
var (
	CacheStatus_name = map[int32]string{
		0: "CACHE_STATUS_UNKNOWN",
		1: "CACHE_STATUS_HIT",
		2: "CACHE_STATUS_MISS",
		3: "CACHE_STATUS_STALE",
		4: "CACHE_STATUS_BYPASS",
	}
	CacheStatus_value = map[string]int32{
		"CACHE_STATUS_UNKNOWN": 0,
		"CACHE_STATUS_HIT":     1,
		"CACHE_STATUS_MISS":    2,
		"CACHE_STATUS_STALE":   3,
		"CACHE_STATUS_BYPASS":  4,
	}
)

func (x CacheStatus) Enum() *CacheStatus {
	p := new(CacheStatus)
	*p = x
	return p
}

func (x CacheStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CacheStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_tunnel_proto_enumTypes[5].Descriptor()
}

func (CacheStatus) Type() protoreflect.EnumType {
	return &file_tunnel_proto_enumTypes[5]
}

func (x CacheStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CacheStatus.Descriptor instead.
func (CacheStatus) EnumDescriptor() ([]byte, []int) {
	return file_tunnel_proto_rawDescGZIP(), []int{5}
}

type ErrorMessage_ErrorType int32

const (
	ErrorMessage_UNKNOWN               ErrorMessage_ErrorType = 0
	ErrorMessage_AUTHENTICATION_FAILED ErrorMessage_ErrorType = 1
	ErrorMessage_TUNNEL_NOT_FOUND      ErrorMessage_ErrorType = 2
	ErrorMessage_SERVICE_UNAVAILABLE   ErrorMessage_ErrorType = 3
	ErrorMessage_REQUEST_TIMEOUT       ErrorMessage_ErrorType = 4
	ErrorMessage_RATE_LIMITED          ErrorMessage_ErrorType = 5
	ErrorMessage_CHUNK_ERROR           ErrorMessage_ErrorType = 6
	ErrorMessage_STREAMING_ERROR       ErrorMessage_ErrorType = 7
)

// Enum value maps for ErrorMessage_ErrorType.
var (
	ErrorMessage_ErrorType_name = map[int32]string{
		0: "UNKNOWN",
		1: "AUTHENTICATION_FAILED",
		2: "TUNNEL_NOT_FOUND",
		3: "SERVICE_UNAVAILABLE",
		4: "REQUEST_TIMEOUT",
		5: "RATE_LIMITED",
		6: "CHUNK_ERROR",
		7: "STREAMING_ERROR",
	}
	ErrorMessage_ErrorType_value = map[string]int32{
		"UNKNOWN":               0,
		"AUTHENTICATION_FAILED": 1,
		"TUNNEL_NOT_FOUND":      2,
		"SERVICE_UNAVAILABLE":   3,
		"REQUEST_TIMEOUT":       4,
		"RATE_LIMITED":          5,
		"CHUNK_ERROR":           6,
		"STREAMING_ERROR":       7,
	}
)

func (x ErrorMessage_ErrorType) Enum() *ErrorMessage_ErrorType {
	p := new(ErrorMessage_ErrorType)
	*p = x
	return p
}

func (x ErrorMessage_ErrorType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ErrorMessage_ErrorType) Descriptor() protoreflect.EnumDescriptor {
	return file_tunnel_proto_enumTypes[6].Descriptor()
}

func (ErrorMessage_ErrorType) Type() protoreflect.EnumType {
	return &file_tunnel_proto_enumTypes[6]
}

func (x ErrorMessage_ErrorType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ErrorMessage_ErrorType.Descriptor instead.
func (ErrorMessage_ErrorType) EnumDescriptor() ([]byte, []int) {
	return file_tunnel_proto_rawDescGZIP(), []int{13, 0}
}

// TunnelMessage represents bidirectional communication over the tunnel
type TunnelMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to MessageType:
	//
	//	*TunnelMessage_Handshake
	//	*TunnelMessage_HttpRequest
	//	*TunnelMessage_HttpResponse
	//	*TunnelMessage_Control
	//	*TunnelMessage_Error
	//	*TunnelMessage_Status
	//	*TunnelMessage_HttpRequestStart
	//	*TunnelMessage_HttpRequestChunk
	//	*TunnelMessage_HttpRequestEnd
	MessageType   isTunnelMessage_MessageType `protobuf_oneof:"message_type"`
	RequestId     string                      `protobuf:"bytes,10,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	Timestamp     int64                       `protobuf:"varint,11,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TunnelMessage) Reset() {
	*x = TunnelMessage{}
	mi := &file_tunnel_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TunnelMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TunnelMessage) ProtoMessage() {}

func (x *TunnelMessage) ProtoReflect() protoreflect.Message {
	mi := &file_tunnel_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TunnelMessage.ProtoReflect.Descriptor instead.
func (*TunnelMessage) Descriptor() ([]byte, []int) {
	return file_tunnel_proto_rawDescGZIP(), []int{0}
}

func (x *TunnelMessage) GetMessageType() isTunnelMessage_MessageType {
	if x != nil {
		return x.MessageType
	}
	return nil
}

func (x *TunnelMessage) GetHandshake() *TunnelHandshake {
	if x != nil {
		if x, ok := x.MessageType.(*TunnelMessage_Handshake); ok {
			return x.Handshake
		}
	}
	return nil
}

func (x *TunnelMessage) GetHttpRequest() *HTTPRequest {
	if x != nil {
		if x, ok := x.MessageType.(*TunnelMessage_HttpRequest); ok {
			return x.HttpRequest
		}
	}
	return nil
}

func (x *TunnelMessage) GetHttpResponse() *HTTPResponse {
	if x != nil {
		if x, ok := x.MessageType.(*TunnelMessage_HttpResponse); ok {
			return x.HttpResponse
		}
	}
	return nil
}

func (x *TunnelMessage) GetControl() *TunnelControl {
	if x != nil {
		if x, ok := x.MessageType.(*TunnelMessage_Control); ok {
			return x.Control
		}
	}
	return nil
}

func (x *TunnelMessage) GetError() *ErrorMessage {
	if x != nil {
		if x, ok := x.MessageType.(*TunnelMessage_Error); ok {
			return x.Error
		}
	}
	return nil
}

func (x *TunnelMessage) GetStatus() *TunnelStatus {
	if x != nil {
		if x, ok := x.MessageType.(*TunnelMessage_Status); ok {
			return x.Status
		}
	}
	return nil
}

func (x *TunnelMessage) GetHttpRequestStart() *HTTPRequestStart {
	if x != nil {
		if x, ok := x.MessageType.(*TunnelMessage_HttpRequestStart); ok {
			return x.HttpRequestStart
		}
	}
	return nil
}

func (x *TunnelMessage) GetHttpRequestChunk() *HTTPRequestChunk {
	if x != nil {
		if x, ok := x.MessageType.(*TunnelMessage_HttpRequestChunk); ok {
			return x.HttpRequestChunk
		}
	}
	return nil
}

func (x *TunnelMessage) GetHttpRequestEnd() *HTTPRequestEnd {
	if x != nil {
		if x, ok := x.MessageType.(*TunnelMessage_HttpRequestEnd); ok {
			return x.HttpRequestEnd
		}
	}
	return nil
}

func (x *TunnelMessage) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *TunnelMessage) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

type isTunnelMessage_MessageType interface {
	isTunnelMessage_MessageType()
}

type TunnelMessage_Handshake struct {
	Handshake *TunnelHandshake `protobuf:"bytes,1,opt,name=handshake,proto3,oneof"`
}

type TunnelMessage_HttpRequest struct {
	HttpRequest *HTTPRequest `protobuf:"bytes,2,opt,name=http_request,json=httpRequest,proto3,oneof"`
}

type TunnelMessage_HttpResponse struct {
	HttpResponse *HTTPResponse `protobuf:"bytes,3,opt,name=http_response,json=httpResponse,proto3,oneof"`
}

type TunnelMessage_Control struct {
	Control *TunnelControl `protobuf:"bytes,4,opt,name=control,proto3,oneof"`
}

type TunnelMessage_Error struct {
	Error *ErrorMessage `protobuf:"bytes,5,opt,name=error,proto3,oneof"`
}

type TunnelMessage_Status struct {
	Status *TunnelStatus `protobuf:"bytes,6,opt,name=status,proto3,oneof"`
}

type TunnelMessage_HttpRequestStart struct {
	// Request-side streaming for large uploads
	HttpRequestStart *HTTPRequestStart `protobuf:"bytes,7,opt,name=http_request_start,json=httpRequestStart,proto3,oneof"`
}

type TunnelMessage_HttpRequestChunk struct {
	HttpRequestChunk *HTTPRequestChunk `protobuf:"bytes,8,opt,name=http_request_chunk,json=httpRequestChunk,proto3,oneof"`
}

type TunnelMessage_HttpRequestEnd struct {
	HttpRequestEnd *HTTPRequestEnd `protobuf:"bytes,9,opt,name=http_request_end,json=httpRequestEnd,proto3,oneof"`
}

func (*TunnelMessage_Handshake) isTunnelMessage_MessageType() {}

func (*TunnelMessage_HttpRequest) isTunnelMessage_MessageType() {}

func (*TunnelMessage_HttpResponse) isTunnelMessage_MessageType() {}

func (*TunnelMessage_Control) isTunnelMessage_MessageType() {}

func (*TunnelMessage_Error) isTunnelMessage_MessageType() {}

func (*TunnelMessage_Status) isTunnelMessage_MessageType() {}

func (*TunnelMessage_HttpRequestStart) isTunnelMessage_MessageType() {}

func (*TunnelMessage_HttpRequestChunk) isTunnelMessage_MessageType() {}

func (*TunnelMessage_HttpRequestEnd) isTunnelMessage_MessageType() {}

// TunnelHandshake initiates the tunnel connection
type TunnelHandshake struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Token         string                 `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	Domain        string                 `protobuf:"bytes,2,opt,name=domain,proto3" json:"domain,omitempty"`
	TargetPort    int32                  `protobuf:"varint,3,opt,name=target_port,json=targetPort,proto3" json:"target_port,omitempty"`
	ClientVersion string                 `protobuf:"bytes,4,opt,name=client_version,json=clientVersion,proto3" json:"client_version,omitempty"`
	Capabilities  *TunnelCapabilities    `protobuf:"bytes,5,opt,name=capabilities,proto3" json:"capabilities,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TunnelHandshake) Reset() {
	*x = TunnelHandshake{}
	mi := &file_tunnel_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TunnelHandshake) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TunnelHandshake) ProtoMessage() {}

func (x *TunnelHandshake) ProtoReflect() protoreflect.Message {
	mi := &file_tunnel_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TunnelHandshake.ProtoReflect.Descriptor instead.
func (*TunnelHandshake) Descriptor() ([]byte, []int) {
	return file_tunnel_proto_rawDescGZIP(), []int{1}
}

func (x *TunnelHandshake) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

func (x *TunnelHandshake) GetDomain() string {
	if x != nil {
		return x.Domain
	}
	return ""
}

func (x *TunnelHandshake) GetTargetPort() int32 {
	if x != nil {
		return x.TargetPort
	}
	return 0
}

func (x *TunnelHandshake) GetClientVersion() string {
	if x != nil {
		return x.ClientVersion
	}
	return ""
}

func (x *TunnelHandshake) GetCapabilities() *TunnelCapabilities {
	if x != nil {
		return x.Capabilities
	}
	return nil
}

// TunnelCapabilities describes client/server capabilities
type TunnelCapabilities struct {
	state                    protoimpl.MessageState `protogen:"open.v1"`
	SupportsChunkedStreaming bool                   `protobuf:"varint,1,opt,name=supports_chunked_streaming,json=supportsChunkedStreaming,proto3" json:"supports_chunked_streaming,omitempty"`
	SupportsCompression      bool                   `protobuf:"varint,2,opt,name=supports_compression,json=supportsCompression,proto3" json:"supports_compression,omitempty"`
	MaxChunkSize             int64                  `protobuf:"varint,3,opt,name=max_chunk_size,json=maxChunkSize,proto3" json:"max_chunk_size,omitempty"`
	SupportedEncodings       []string               `protobuf:"bytes,4,rep,name=supported_encodings,json=supportedEncodings,proto3" json:"supported_encodings,omitempty"`
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *TunnelCapabilities) Reset() {
	*x = TunnelCapabilities{}
	mi := &file_tunnel_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TunnelCapabilities) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TunnelCapabilities) ProtoMessage() {}

func (x *TunnelCapabilities) ProtoReflect() protoreflect.Message {
	mi := &file_tunnel_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TunnelCapabilities.ProtoReflect.Descriptor instead.
func (*TunnelCapabilities) Descriptor() ([]byte, []int) {
	return file_tunnel_proto_rawDescGZIP(), []int{2}
}

func (x *TunnelCapabilities) GetSupportsChunkedStreaming() bool {
	if x != nil {
		return x.SupportsChunkedStreaming
	}
	return false
}

func (x *TunnelCapabilities) GetSupportsCompression() bool {
	if x != nil {
		return x.SupportsCompression
	}
	return false
}

func (x *TunnelCapabilities) GetMaxChunkSize() int64 {
	if x != nil {
		return x.MaxChunkSize
	}
	return 0
}

func (x *TunnelCapabilities) GetSupportedEncodings() []string {
	if x != nil {
		return x.SupportedEncodings
	}
	return nil
}

// HTTPRequest represents an HTTP request to be forwarded
type HTTPRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Method        string                 `protobuf:"bytes,1,opt,name=method,proto3" json:"method,omitempty"`
	Path          string                 `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	Query         string                 `protobuf:"bytes,3,opt,name=query,proto3" json:"query,omitempty"`
	Headers       map[string]string      `protobuf:"bytes,4,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Body          []byte                 `protobuf:"bytes,5,opt,name=body,proto3" json:"body,omitempty"`
	RemoteAddr    string                 `protobuf:"bytes,6,opt,name=remote_addr,json=remoteAddr,proto3" json:"remote_addr,omitempty"`
	IsLargeFile   bool                   `protobuf:"varint,7,opt,name=is_large_file,json=isLargeFile,proto3" json:"is_large_file,omitempty"`  // Indicates if this should use chunked streaming
	ExpectedSize  int64                  `protobuf:"varint,8,opt,name=expected_size,json=expectedSize,proto3" json:"expected_size,omitempty"` // Expected response size for optimization
	ClientIp      string                 `protobuf:"bytes,9,opt,name=client_ip,json=clientIp,proto3" json:"client_ip,omitempty"`              // Client IP address
	Metadata      *RequestMetadata       `protobuf:"bytes,10,opt,name=metadata,proto3" json:"metadata,omitempty"`                             // Request metadata
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HTTPRequest) Reset() {
	*x = HTTPRequest{}
	mi := &file_tunnel_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HTTPRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HTTPRequest) ProtoMessage() {}

func (x *HTTPRequest) ProtoReflect() protoreflect.Message {
	mi := &file_tunnel_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HTTPRequest.ProtoReflect.Descriptor instead.
func (*HTTPRequest) Descriptor() ([]byte, []int) {
	return file_tunnel_proto_rawDescGZIP(), []int{3}
}

func (x *HTTPRequest) GetMethod() string {
	if x != nil {
		return x.Method
	}
	return ""
}

func (x *HTTPRequest) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *HTTPRequest) GetQuery() string {
	if x != nil {
		return x.Query
	}
	return ""
}

func (x *HTTPRequest) GetHeaders() map[string]string {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *HTTPRequest) GetBody() []byte {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *HTTPRequest) GetRemoteAddr() string {
	if x != nil {
		return x.RemoteAddr
	}
	return ""
}

func (x *HTTPRequest) GetIsLargeFile() bool {
	if x != nil {
		return x.IsLargeFile
	}
	return false
}

func (x *HTTPRequest) GetExpectedSize() int64 {
	if x != nil {
		return x.ExpectedSize
	}
	return 0
}

func (x *HTTPRequest) GetClientIp() string {
	if x != nil {
		return x.ClientIp
	}
	return ""
}

func (x *HTTPRequest) GetMetadata() *RequestMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// HTTPResponse represents an HTTP response from the local service
type HTTPResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	StatusCode    int32                  `protobuf:"varint,1,opt,name=status_code,json=statusCode,proto3" json:"status_code,omitempty"`
	StatusText    string                 `protobuf:"bytes,2,opt,name=status_text,json=statusText,proto3" json:"status_text,omitempty"`
	Headers       map[string]string      `protobuf:"bytes,3,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Body          []byte                 `protobuf:"bytes,4,opt,name=body,proto3" json:"body,omitempty"`
	IsChunked     bool                   `protobuf:"varint,5,opt,name=is_chunked,json=isChunked,proto3" json:"is_chunked,omitempty"` // Indicates if response is chunked
	ChunkId       string                 `protobuf:"bytes,6,opt,name=chunk_id,json=chunkId,proto3" json:"chunk_id,omitempty"`        // For chunked responses
	Metadata      *ResponseMetadata      `protobuf:"bytes,7,opt,name=metadata,proto3" json:"metadata,omitempty"`                     // Response metadata
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HTTPResponse) Reset() {
	*x = HTTPResponse{}
	mi := &file_tunnel_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HTTPResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HTTPResponse) ProtoMessage() {}

func (x *HTTPResponse) ProtoReflect() protoreflect.Message {
	mi := &file_tunnel_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HTTPResponse.ProtoReflect.Descriptor instead.
func (*HTTPResponse) Descriptor() ([]byte, []int) {
	return file_tunnel_proto_rawDescGZIP(), []int{4}
}

func (x *HTTPResponse) GetStatusCode() int32 {
	if x != nil {
		return x.StatusCode
	}
	return 0
}

func (x *HTTPResponse) GetStatusText() string {
	if x != nil {
		return x.StatusText
	}
	return ""
}

func (x *HTTPResponse) GetHeaders() map[string]string {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *HTTPResponse) GetBody() []byte {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *HTTPResponse) GetIsChunked() bool {
	if x != nil {
		return x.IsChunked
	}
	return false
}

func (x *HTTPResponse) GetChunkId() string {
	if x != nil {
		return x.ChunkId
	}
	return ""
}

func (x *HTTPResponse) GetMetadata() *ResponseMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// Large file streaming messages for memory-efficient transfers
type LargeFileRequest struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	RequestId         string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	HttpRequest       *HTTPRequest           `protobuf:"bytes,2,opt,name=http_request,json=httpRequest,proto3" json:"http_request,omitempty"`
	ChunkSize         int32                  `protobuf:"varint,3,opt,name=chunk_size,json=chunkSize,proto3" json:"chunk_size,omitempty"` // Preferred chunk size (default: 1MB)
	EnableCompression bool                   `protobuf:"varint,4,opt,name=enable_compression,json=enableCompression,proto3" json:"enable_compression,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *LargeFileRequest) Reset() {
	*x = LargeFileRequest{}
	mi := &file_tunnel_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LargeFileRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LargeFileRequest) ProtoMessage() {}

func (x *LargeFileRequest) ProtoReflect() protoreflect.Message {
	mi := &file_tunnel_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LargeFileRequest.ProtoReflect.Descriptor instead.
func (*LargeFileRequest) Descriptor() ([]byte, []int) {
	return file_tunnel_proto_rawDescGZIP(), []int{5}
}

func (x *LargeFileRequest) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *LargeFileRequest) GetHttpRequest() *HTTPRequest {
	if x != nil {
		return x.HttpRequest
	}
	return nil
}

func (x *LargeFileRequest) GetChunkSize() int32 {
	if x != nil {
		return x.ChunkSize
	}
	return 0
}

func (x *LargeFileRequest) GetEnableCompression() bool {
	if x != nil {
		return x.EnableCompression
	}
	return false
}

type LargeFileChunk struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	ChunkNumber   int32                  `protobuf:"varint,2,opt,name=chunk_number,json=chunkNumber,proto3" json:"chunk_number,omitempty"`
	Data          []byte                 `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	IsFinal       bool                   `protobuf:"varint,4,opt,name=is_final,json=isFinal,proto3" json:"is_final,omitempty"`
	TotalSize     int64                  `protobuf:"varint,5,opt,name=total_size,json=totalSize,proto3" json:"total_size,omitempty"` // Total file size if known
	ContentType   string                 `protobuf:"bytes,6,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
	Headers       map[string]string      `protobuf:"bytes,7,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // HTTP headers (sent with first chunk)
	StatusCode    int32                  `protobuf:"varint,8,opt,name=status_code,json=statusCode,proto3" json:"status_code,omitempty"`                                                  // HTTP status (sent with first chunk)
	ErrorMessage  string                 `protobuf:"bytes,9,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`                                             // Error if chunk failed
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LargeFileChunk) Reset() {
	*x = LargeFileChunk{}
	mi := &file_tunnel_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LargeFileChunk) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LargeFileChunk) ProtoMessage() {}

func (x *LargeFileChunk) ProtoReflect() protoreflect.Message {
	mi := &file_tunnel_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LargeFileChunk.ProtoReflect.Descriptor instead.
func (*LargeFileChunk) Descriptor() ([]byte, []int) {
	return file_tunnel_proto_rawDescGZIP(), []int{6}
}

func (x *LargeFileChunk) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *LargeFileChunk) GetChunkNumber() int32 {
	if x != nil {
		return x.ChunkNumber
	}
	return 0
}

func (x *LargeFileChunk) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *LargeFileChunk) GetIsFinal() bool {
	if x != nil {
		return x.IsFinal
	}
	return false
}

func (x *LargeFileChunk) GetTotalSize() int64 {
	if x != nil {
		return x.TotalSize
	}
	return 0
}

func (x *LargeFileChunk) GetContentType() string {
	if x != nil {
		return x.ContentType
	}
	return ""
}

func (x *LargeFileChunk) GetHeaders() map[string]string {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *LargeFileChunk) GetStatusCode() int32 {
	if x != nil {
		return x.StatusCode
	}
	return 0
}

func (x *LargeFileChunk) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

// Request-side streaming (server -> client) for large uploads
type HTTPRequestStart struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	Method        string                 `protobuf:"bytes,2,opt,name=method,proto3" json:"method,omitempty"`
	Path          string                 `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
	Query         string                 `protobuf:"bytes,4,opt,name=query,proto3" json:"query,omitempty"`
	Headers       map[string]string      `protobuf:"bytes,5,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	ClientIp      string                 `protobuf:"bytes,6,opt,name=client_ip,json=clientIp,proto3" json:"client_ip,omitempty"`
	IsLargeFile   bool                   `protobuf:"varint,7,opt,name=is_large_file,json=isLargeFile,proto3" json:"is_large_file,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HTTPRequestStart) Reset() {
	*x = HTTPRequestStart{}
	mi := &file_tunnel_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HTTPRequestStart) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HTTPRequestStart) ProtoMessage() {}

func (x *HTTPRequestStart) ProtoReflect() protoreflect.Message {
	mi := &file_tunnel_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HTTPRequestStart.ProtoReflect.Descriptor instead.
func (*HTTPRequestStart) Descriptor() ([]byte, []int) {
	return file_tunnel_proto_rawDescGZIP(), []int{7}
}

func (x *HTTPRequestStart) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *HTTPRequestStart) GetMethod() string {
	if x != nil {
		return x.Method
	}
	return ""
}

func (x *HTTPRequestStart) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *HTTPRequestStart) GetQuery() string {
	if x != nil {
		return x.Query
	}
	return ""
}

func (x *HTTPRequestStart) GetHeaders() map[string]string {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *HTTPRequestStart) GetClientIp() string {
	if x != nil {
		return x.ClientIp
	}
	return ""
}

func (x *HTTPRequestStart) GetIsLargeFile() bool {
	if x != nil {
		return x.IsLargeFile
	}
	return false
}

type HTTPRequestChunk struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	Data          []byte                 `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HTTPRequestChunk) Reset() {
	*x = HTTPRequestChunk{}
	mi := &file_tunnel_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HTTPRequestChunk) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HTTPRequestChunk) ProtoMessage() {}

func (x *HTTPRequestChunk) ProtoReflect() protoreflect.Message {
	mi := &file_tunnel_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HTTPRequestChunk.ProtoReflect.Descriptor instead.
func (*HTTPRequestChunk) Descriptor() ([]byte, []int) {
	return file_tunnel_proto_rawDescGZIP(), []int{8}
}

func (x *HTTPRequestChunk) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *HTTPRequestChunk) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

type HTTPRequestEnd struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HTTPRequestEnd) Reset() {
	*x = HTTPRequestEnd{}
	mi := &file_tunnel_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HTTPRequestEnd) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HTTPRequestEnd) ProtoMessage() {}

func (x *HTTPRequestEnd) ProtoReflect() protoreflect.Message {
	mi := &file_tunnel_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HTTPRequestEnd.ProtoReflect.Descriptor instead.
func (*HTTPRequestEnd) Descriptor() ([]byte, []int) {
	return file_tunnel_proto_rawDescGZIP(), []int{9}
}

func (x *HTTPRequestEnd) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

// TunnelControl handles tunnel lifecycle management
type TunnelControl struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to ControlType:
	//
	//	*TunnelControl_Handshake
	//	*TunnelControl_Status
	//	*TunnelControl_Config
	//	*TunnelControl_Metrics
	//	*TunnelControl_EstablishRequest
	ControlType   isTunnelControl_ControlType `protobuf_oneof:"control_type"`
	Message       string                      `protobuf:"bytes,10,opt,name=message,proto3" json:"message,omitempty"`
	Timestamp     int64                       `protobuf:"varint,11,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TunnelControl) Reset() {
	*x = TunnelControl{}
	mi := &file_tunnel_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TunnelControl) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TunnelControl) ProtoMessage() {}

func (x *TunnelControl) ProtoReflect() protoreflect.Message {
	mi := &file_tunnel_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TunnelControl.ProtoReflect.Descriptor instead.
func (*TunnelControl) Descriptor() ([]byte, []int) {
	return file_tunnel_proto_rawDescGZIP(), []int{10}
}

func (x *TunnelControl) GetControlType() isTunnelControl_ControlType {
	if x != nil {
		return x.ControlType
	}
	return nil
}

func (x *TunnelControl) GetHandshake() *TunnelHandshake {
	if x != nil {
		if x, ok := x.ControlType.(*TunnelControl_Handshake); ok {
			return x.Handshake
		}
	}
	return nil
}

func (x *TunnelControl) GetStatus() *TunnelStatus {
	if x != nil {
		if x, ok := x.ControlType.(*TunnelControl_Status); ok {
			return x.Status
		}
	}
	return nil
}

func (x *TunnelControl) GetConfig() *TunnelConfig {
	if x != nil {
		if x, ok := x.ControlType.(*TunnelControl_Config); ok {
			return x.Config
		}
	}
	return nil
}

func (x *TunnelControl) GetMetrics() *TunnelMetrics {
	if x != nil {
		if x, ok := x.ControlType.(*TunnelControl_Metrics); ok {
			return x.Metrics
		}
	}
	return nil
}

func (x *TunnelControl) GetEstablishRequest() *TunnelEstablishRequest {
	if x != nil {
		if x, ok := x.ControlType.(*TunnelControl_EstablishRequest); ok {
			return x.EstablishRequest
		}
	}
	return nil
}

func (x *TunnelControl) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *TunnelControl) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

type isTunnelControl_ControlType interface {
	isTunnelControl_ControlType()
}

type TunnelControl_Handshake struct {
	Handshake *TunnelHandshake `protobuf:"bytes,1,opt,name=handshake,proto3,oneof"`
}

type TunnelControl_Status struct {
	Status *TunnelStatus `protobuf:"bytes,2,opt,name=status,proto3,oneof"`
}

type TunnelControl_Config struct {
	Config *TunnelConfig `protobuf:"bytes,3,opt,name=config,proto3,oneof"`
}

type TunnelControl_Metrics struct {
	Metrics *TunnelMetrics `protobuf:"bytes,4,opt,name=metrics,proto3,oneof"`
}

type TunnelControl_EstablishRequest struct {
	EstablishRequest *TunnelEstablishRequest `protobuf:"bytes,5,opt,name=establish_request,json=establishRequest,proto3,oneof"`
}

func (*TunnelControl_Handshake) isTunnelControl_ControlType() {}

func (*TunnelControl_Status) isTunnelControl_ControlType() {}

func (*TunnelControl_Config) isTunnelControl_ControlType() {}

func (*TunnelControl_Metrics) isTunnelControl_ControlType() {}

func (*TunnelControl_EstablishRequest) isTunnelControl_ControlType() {}

// TunnelEstablishRequest requests client to establish a specific tunnel type
type TunnelEstablishRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TunnelType    TunnelType             `protobuf:"varint,1,opt,name=tunnel_type,json=tunnelType,proto3,enum=tunnel.TunnelType" json:"tunnel_type,omitempty"`
	Domain        string                 `protobuf:"bytes,2,opt,name=domain,proto3" json:"domain,omitempty"`
	TargetPort    int32                  `protobuf:"varint,3,opt,name=target_port,json=targetPort,proto3" json:"target_port,omitempty"`
	RequestId     string                 `protobuf:"bytes,4,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	TimeoutMs     int64                  `protobuf:"varint,5,opt,name=timeout_ms,json=timeoutMs,proto3" json:"timeout_ms,omitempty"` // How long server will wait
	Reason        string                 `protobuf:"bytes,6,opt,name=reason,proto3" json:"reason,omitempty"`                         // Reason for the request
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TunnelEstablishRequest) Reset() {
	*x = TunnelEstablishRequest{}
	mi := &file_tunnel_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TunnelEstablishRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TunnelEstablishRequest) ProtoMessage() {}

func (x *TunnelEstablishRequest) ProtoReflect() protoreflect.Message {
	mi := &file_tunnel_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TunnelEstablishRequest.ProtoReflect.Descriptor instead.
func (*TunnelEstablishRequest) Descriptor() ([]byte, []int) {
	return file_tunnel_proto_rawDescGZIP(), []int{11}
}

func (x *TunnelEstablishRequest) GetTunnelType() TunnelType {
	if x != nil {
		return x.TunnelType
	}
	return TunnelType_TUNNEL_TYPE_UNKNOWN
}

func (x *TunnelEstablishRequest) GetDomain() string {
	if x != nil {
		return x.Domain
	}
	return ""
}

func (x *TunnelEstablishRequest) GetTargetPort() int32 {
	if x != nil {
		return x.TargetPort
	}
	return 0
}

func (x *TunnelEstablishRequest) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *TunnelEstablishRequest) GetTimeoutMs() int64 {
	if x != nil {
		return x.TimeoutMs
	}
	return 0
}

func (x *TunnelEstablishRequest) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

// TunnelConfig for configuration updates
type TunnelConfig struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	MaxConcurrent     int32                  `protobuf:"varint,1,opt,name=max_concurrent,json=maxConcurrent,proto3" json:"max_concurrent,omitempty"`
	TimeoutSeconds    int32                  `protobuf:"varint,2,opt,name=timeout_seconds,json=timeoutSeconds,proto3" json:"timeout_seconds,omitempty"`
	EnableCompression bool                   `protobuf:"varint,3,opt,name=enable_compression,json=enableCompression,proto3" json:"enable_compression,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *TunnelConfig) Reset() {
	*x = TunnelConfig{}
	mi := &file_tunnel_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TunnelConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TunnelConfig) ProtoMessage() {}

func (x *TunnelConfig) ProtoReflect() protoreflect.Message {
	mi := &file_tunnel_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TunnelConfig.ProtoReflect.Descriptor instead.
func (*TunnelConfig) Descriptor() ([]byte, []int) {
	return file_tunnel_proto_rawDescGZIP(), []int{12}
}

func (x *TunnelConfig) GetMaxConcurrent() int32 {
	if x != nil {
		return x.MaxConcurrent
	}
	return 0
}

func (x *TunnelConfig) GetTimeoutSeconds() int32 {
	if x != nil {
		return x.TimeoutSeconds
	}
	return 0
}

func (x *TunnelConfig) GetEnableCompression() bool {
	if x != nil {
		return x.EnableCompression
	}
	return false
}

// ErrorMessage provides structured error information
type ErrorMessage struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Type          ErrorMessage_ErrorType `protobuf:"varint,1,opt,name=type,proto3,enum=tunnel.ErrorMessage_ErrorType" json:"type,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Details       string                 `protobuf:"bytes,3,opt,name=details,proto3" json:"details,omitempty"`
	Code          int32                  `protobuf:"varint,4,opt,name=code,proto3" json:"code,omitempty"`
	Retryable     bool                   `protobuf:"varint,5,opt,name=retryable,proto3" json:"retryable,omitempty"` // Whether the error is retryable
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ErrorMessage) Reset() {
	*x = ErrorMessage{}
	mi := &file_tunnel_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ErrorMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ErrorMessage) ProtoMessage() {}

func (x *ErrorMessage) ProtoReflect() protoreflect.Message {
	mi := &file_tunnel_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ErrorMessage.ProtoReflect.Descriptor instead.
func (*ErrorMessage) Descriptor() ([]byte, []int) {
	return file_tunnel_proto_rawDescGZIP(), []int{13}
}

func (x *ErrorMessage) GetType() ErrorMessage_ErrorType {
	if x != nil {
		return x.Type
	}
	return ErrorMessage_UNKNOWN
}

func (x *ErrorMessage) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *ErrorMessage) GetDetails() string {
	if x != nil {
		return x.Details
	}
	return ""
}

func (x *ErrorMessage) GetCode() int32 {
	if x != nil {
		return x.Code
	}
	return 0
}

func (x *ErrorMessage) GetRetryable() bool {
	if x != nil {
		return x.Retryable
	}
	return false
}

// TunnelStatus provides tunnel state information
type TunnelStatus struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	State             TunnelState            `protobuf:"varint,1,opt,name=state,proto3,enum=tunnel.TunnelState" json:"state,omitempty"`
	Domain            string                 `protobuf:"bytes,2,opt,name=domain,proto3" json:"domain,omitempty"`
	TargetPort        int32                  `protobuf:"varint,3,opt,name=target_port,json=targetPort,proto3" json:"target_port,omitempty"`
	ConnectedAt       int64                  `protobuf:"varint,4,opt,name=connected_at,json=connectedAt,proto3" json:"connected_at,omitempty"`
	ActiveConnections int32                  `protobuf:"varint,5,opt,name=active_connections,json=activeConnections,proto3" json:"active_connections,omitempty"`
	LastActivity      int64                  `protobuf:"varint,6,opt,name=last_activity,json=lastActivity,proto3" json:"last_activity,omitempty"`
	ErrorMessage      string                 `protobuf:"bytes,7,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *TunnelStatus) Reset() {
	*x = TunnelStatus{}
	mi := &file_tunnel_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TunnelStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TunnelStatus) ProtoMessage() {}

func (x *TunnelStatus) ProtoReflect() protoreflect.Message {
	mi := &file_tunnel_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TunnelStatus.ProtoReflect.Descriptor instead.
func (*TunnelStatus) Descriptor() ([]byte, []int) {
	return file_tunnel_proto_rawDescGZIP(), []int{14}
}

func (x *TunnelStatus) GetState() TunnelState {
	if x != nil {
		return x.State
	}
	return TunnelState_TUNNEL_STATE_UNKNOWN
}

func (x *TunnelStatus) GetDomain() string {
	if x != nil {
		return x.Domain
	}
	return ""
}

func (x *TunnelStatus) GetTargetPort() int32 {
	if x != nil {
		return x.TargetPort
	}
	return 0
}

func (x *TunnelStatus) GetConnectedAt() int64 {
	if x != nil {
		return x.ConnectedAt
	}
	return 0
}

func (x *TunnelStatus) GetActiveConnections() int32 {
	if x != nil {
		return x.ActiveConnections
	}
	return 0
}

func (x *TunnelStatus) GetLastActivity() int64 {
	if x != nil {
		return x.LastActivity
	}
	return 0
}

func (x *TunnelStatus) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

// TunnelMetrics provides performance metrics
type TunnelMetrics struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	TotalRequests       int64                  `protobuf:"varint,1,opt,name=total_requests,json=totalRequests,proto3" json:"total_requests,omitempty"`
	TotalResponses      int64                  `protobuf:"varint,2,opt,name=total_responses,json=totalResponses,proto3" json:"total_responses,omitempty"`
	TotalBytesSent      int64                  `protobuf:"varint,3,opt,name=total_bytes_sent,json=totalBytesSent,proto3" json:"total_bytes_sent,omitempty"`
	TotalBytesReceived  int64                  `protobuf:"varint,4,opt,name=total_bytes_received,json=totalBytesReceived,proto3" json:"total_bytes_received,omitempty"`
	ActiveStreams       int64                  `protobuf:"varint,5,opt,name=active_streams,json=activeStreams,proto3" json:"active_streams,omitempty"`
	ChunkedTransfers    int64                  `protobuf:"varint,6,opt,name=chunked_transfers,json=chunkedTransfers,proto3" json:"chunked_transfers,omitempty"`
	AverageResponseTime float64                `protobuf:"fixed64,7,opt,name=average_response_time,json=averageResponseTime,proto3" json:"average_response_time,omitempty"`
	ErrorsCount         int64                  `protobuf:"varint,8,opt,name=errors_count,json=errorsCount,proto3" json:"errors_count,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *TunnelMetrics) Reset() {
	*x = TunnelMetrics{}
	mi := &file_tunnel_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TunnelMetrics) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TunnelMetrics) ProtoMessage() {}

func (x *TunnelMetrics) ProtoReflect() protoreflect.Message {
	mi := &file_tunnel_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TunnelMetrics.ProtoReflect.Descriptor instead.
func (*TunnelMetrics) Descriptor() ([]byte, []int) {
	return file_tunnel_proto_rawDescGZIP(), []int{15}
}

func (x *TunnelMetrics) GetTotalRequests() int64 {
	if x != nil {
		return x.TotalRequests
	}
	return 0
}

func (x *TunnelMetrics) GetTotalResponses() int64 {
	if x != nil {
		return x.TotalResponses
	}
	return 0
}

func (x *TunnelMetrics) GetTotalBytesSent() int64 {
	if x != nil {
		return x.TotalBytesSent
	}
	return 0
}

func (x *TunnelMetrics) GetTotalBytesReceived() int64 {
	if x != nil {
		return x.TotalBytesReceived
	}
	return 0
}

func (x *TunnelMetrics) GetActiveStreams() int64 {
	if x != nil {
		return x.ActiveStreams
	}
	return 0
}

func (x *TunnelMetrics) GetChunkedTransfers() int64 {
	if x != nil {
		return x.ChunkedTransfers
	}
	return 0
}

func (x *TunnelMetrics) GetAverageResponseTime() float64 {
	if x != nil {
		return x.AverageResponseTime
	}
	return 0
}

func (x *TunnelMetrics) GetErrorsCount() int64 {
	if x != nil {
		return x.ErrorsCount
	}
	return 0
}

// Health check messages
type HealthCheckRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Service       string                 `protobuf:"bytes,1,opt,name=service,proto3" json:"service,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HealthCheckRequest) Reset() {
	*x = HealthCheckRequest{}
	mi := &file_tunnel_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HealthCheckRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealthCheckRequest) ProtoMessage() {}

func (x *HealthCheckRequest) ProtoReflect() protoreflect.Message {
	mi := &file_tunnel_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HealthCheckRequest.ProtoReflect.Descriptor instead.
func (*HealthCheckRequest) Descriptor() ([]byte, []int) {
	return file_tunnel_proto_rawDescGZIP(), []int{16}
}

func (x *HealthCheckRequest) GetService() string {
	if x != nil {
		return x.Service
	}
	return ""
}

type HealthCheckResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Status        HealthStatus           `protobuf:"varint,1,opt,name=status,proto3,enum=tunnel.HealthStatus" json:"status,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Metrics       *TunnelMetrics         `protobuf:"bytes,3,opt,name=metrics,proto3" json:"metrics,omitempty"`
	Details       map[string]string      `protobuf:"bytes,4,rep,name=details,proto3" json:"details,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Additional health details
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HealthCheckResponse) Reset() {
	*x = HealthCheckResponse{}
	mi := &file_tunnel_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HealthCheckResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealthCheckResponse) ProtoMessage() {}

func (x *HealthCheckResponse) ProtoReflect() protoreflect.Message {
	mi := &file_tunnel_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HealthCheckResponse.ProtoReflect.Descriptor instead.
func (*HealthCheckResponse) Descriptor() ([]byte, []int) {
	return file_tunnel_proto_rawDescGZIP(), []int{17}
}

func (x *HealthCheckResponse) GetStatus() HealthStatus {
	if x != nil {
		return x.Status
	}
	return HealthStatus_HEALTH_STATUS_UNKNOWN
}

func (x *HealthCheckResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *HealthCheckResponse) GetMetrics() *TunnelMetrics {
	if x != nil {
		return x.Metrics
	}
	return nil
}

func (x *HealthCheckResponse) GetDetails() map[string]string {
	if x != nil {
		return x.Details
	}
	return nil
}

// Request metadata for tracking and optimization
type RequestMetadata struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Type          RequestType            `protobuf:"varint,1,opt,name=type,proto3,enum=tunnel.RequestType" json:"type,omitempty"`
	Priority      Priority               `protobuf:"varint,2,opt,name=priority,proto3,enum=tunnel.Priority" json:"priority,omitempty"`
	TimeoutMs     int64                  `protobuf:"varint,3,opt,name=timeout_ms,json=timeoutMs,proto3" json:"timeout_ms,omitempty"`
	TraceId       string                 `protobuf:"bytes,4,opt,name=trace_id,json=traceId,proto3" json:"trace_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RequestMetadata) Reset() {
	*x = RequestMetadata{}
	mi := &file_tunnel_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RequestMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RequestMetadata) ProtoMessage() {}

func (x *RequestMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_tunnel_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RequestMetadata.ProtoReflect.Descriptor instead.
func (*RequestMetadata) Descriptor() ([]byte, []int) {
	return file_tunnel_proto_rawDescGZIP(), []int{18}
}

func (x *RequestMetadata) GetType() RequestType {
	if x != nil {
		return x.Type
	}
	return RequestType_REQUEST_TYPE_UNKNOWN
}

func (x *RequestMetadata) GetPriority() Priority {
	if x != nil {
		return x.Priority
	}
	return Priority_PRIORITY_UNKNOWN
}

func (x *RequestMetadata) GetTimeoutMs() int64 {
	if x != nil {
		return x.TimeoutMs
	}
	return 0
}

func (x *RequestMetadata) GetTraceId() string {
	if x != nil {
		return x.TraceId
	}
	return ""
}

// Response metadata for performance tracking
type ResponseMetadata struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	ProcessingTimeMs int64                  `protobuf:"varint,1,opt,name=processing_time_ms,json=processingTimeMs,proto3" json:"processing_time_ms,omitempty"`
	ResponseSize     int64                  `protobuf:"varint,2,opt,name=response_size,json=responseSize,proto3" json:"response_size,omitempty"`
	CacheStatus      CacheStatus            `protobuf:"varint,3,opt,name=cache_status,json=cacheStatus,proto3,enum=tunnel.CacheStatus" json:"cache_status,omitempty"`
	ServerId         string                 `protobuf:"bytes,4,opt,name=server_id,json=serverId,proto3" json:"server_id,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ResponseMetadata) Reset() {
	*x = ResponseMetadata{}
	mi := &file_tunnel_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResponseMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResponseMetadata) ProtoMessage() {}

func (x *ResponseMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_tunnel_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResponseMetadata.ProtoReflect.Descriptor instead.
func (*ResponseMetadata) Descriptor() ([]byte, []int) {
	return file_tunnel_proto_rawDescGZIP(), []int{19}
}

func (x *ResponseMetadata) GetProcessingTimeMs() int64 {
	if x != nil {
		return x.ProcessingTimeMs
	}
	return 0
}

func (x *ResponseMetadata) GetResponseSize() int64 {
	if x != nil {
		return x.ResponseSize
	}
	return 0
}

func (x *ResponseMetadata) GetCacheStatus() CacheStatus {
	if x != nil {
		return x.CacheStatus
	}
	return CacheStatus_CACHE_STATUS_UNKNOWN
}

func (x *ResponseMetadata) GetServerId() string {
	if x != nil {
		return x.ServerId
	}
	return ""
}

var File_tunnel_proto protoreflect.FileDescriptor

const file_tunnel_proto_rawDesc = "" +
	"\n" +
	"\ftunnel.proto\x12\x06tunnel\"\xf5\x04\n" +
	"\rTunnelMessage\x127\n" +
	"\thandshake\x18\x01 \x01(\v2\x17.tunnel.TunnelHandshakeH\x00R\thandshake\x128\n" +
	"\fhttp_request\x18\x02 \x01(\v2\x13.tunnel.HTTPRequestH\x00R\vhttpRequest\x12;\n" +
	"\rhttp_response\x18\x03 \x01(\v2\x14.tunnel.HTTPResponseH\x00R\fhttpResponse\x121\n" +
	"\acontrol\x18\x04 \x01(\v2\x15.tunnel.TunnelControlH\x00R\acontrol\x12,\n" +
	"\x05error\x18\x05 \x01(\v2\x14.tunnel.ErrorMessageH\x00R\x05error\x12.\n" +
	"\x06status\x18\x06 \x01(\v2\x14.tunnel.TunnelStatusH\x00R\x06status\x12H\n" +
	"\x12http_request_start\x18\a \x01(\v2\x18.tunnel.HTTPRequestStartH\x00R\x10httpRequestStart\x12H\n" +
	"\x12http_request_chunk\x18\b \x01(\v2\x18.tunnel.HTTPRequestChunkH\x00R\x10httpRequestChunk\x12B\n" +
	"\x10http_request_end\x18\t \x01(\v2\x16.tunnel.HTTPRequestEndH\x00R\x0ehttpRequestEnd\x12\x1d\n" +
	"\n" +
	"request_id\x18\n" +
	" \x01(\tR\trequestId\x12\x1c\n" +
	"\ttimestamp\x18\v \x01(\x03R\ttimestampB\x0e\n" +
	"\fmessage_type\"\xc7\x01\n" +
	"\x0fTunnelHandshake\x12\x14\n" +
	"\x05token\x18\x01 \x01(\tR\x05token\x12\x16\n" +
	"\x06domain\x18\x02 \x01(\tR\x06domain\x12\x1f\n" +
	"\vtarget_port\x18\x03 \x01(\x05R\n" +
	"targetPort\x12%\n" +
	"\x0eclient_version\x18\x04 \x01(\tR\rclientVersion\x12>\n" +
	"\fcapabilities\x18\x05 \x01(\v2\x1a.tunnel.TunnelCapabilitiesR\fcapabilities\"\xdc\x01\n" +
	"\x12TunnelCapabilities\x12<\n" +
	"\x1asupports_chunked_streaming\x18\x01 \x01(\bR\x18supportsChunkedStreaming\x121\n" +
	"\x14supports_compression\x18\x02 \x01(\bR\x13supportsCompression\x12$\n" +
	"\x0emax_chunk_size\x18\x03 \x01(\x03R\fmaxChunkSize\x12/\n" +
	"\x13supported_encodings\x18\x04 \x03(\tR\x12supportedEncodings\"\x97\x03\n" +
	"\vHTTPRequest\x12\x16\n" +
	"\x06method\x18\x01 \x01(\tR\x06method\x12\x12\n" +
	"\x04path\x18\x02 \x01(\tR\x04path\x12\x14\n" +
	"\x05query\x18\x03 \x01(\tR\x05query\x12:\n" +
	"\aheaders\x18\x04 \x03(\v2 .tunnel.HTTPRequest.HeadersEntryR\aheaders\x12\x12\n" +
	"\x04body\x18\x05 \x01(\fR\x04body\x12\x1f\n" +
	"\vremote_addr\x18\x06 \x01(\tR\n" +
	"remoteAddr\x12\"\n" +
	"\ris_large_file\x18\a \x01(\bR\visLargeFile\x12#\n" +
	"\rexpected_size\x18\b \x01(\x03R\fexpectedSize\x12\x1b\n" +
	"\tclient_ip\x18\t \x01(\tR\bclientIp\x123\n" +
	"\bmetadata\x18\n" +
	" \x01(\v2\x17.tunnel.RequestMetadataR\bmetadata\x1a:\n" +
	"\fHeadersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xcd\x02\n" +
	"\fHTTPResponse\x12\x1f\n" +
	"\vstatus_code\x18\x01 \x01(\x05R\n" +
	"statusCode\x12\x1f\n" +
	"\vstatus_text\x18\x02 \x01(\tR\n" +
	"statusText\x12;\n" +
	"\aheaders\x18\x03 \x03(\v2!.tunnel.HTTPResponse.HeadersEntryR\aheaders\x12\x12\n" +
	"\x04body\x18\x04 \x01(\fR\x04body\x12\x1d\n" +
	"\n" +
	"is_chunked\x18\x05 \x01(\bR\tisChunked\x12\x19\n" +
	"\bchunk_id\x18\x06 \x01(\tR\achunkId\x124\n" +
	"\bmetadata\x18\a \x01(\v2\x18.tunnel.ResponseMetadataR\bmetadata\x1a:\n" +
	"\fHeadersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xb7\x01\n" +
	"\x10LargeFileRequest\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x126\n" +
	"\fhttp_request\x18\x02 \x01(\v2\x13.tunnel.HTTPRequestR\vhttpRequest\x12\x1d\n" +
	"\n" +
	"chunk_size\x18\x03 \x01(\x05R\tchunkSize\x12-\n" +
	"\x12enable_compression\x18\x04 \x01(\bR\x11enableCompression\"\x84\x03\n" +
	"\x0eLargeFileChunk\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12!\n" +
	"\fchunk_number\x18\x02 \x01(\x05R\vchunkNumber\x12\x12\n" +
	"\x04data\x18\x03 \x01(\fR\x04data\x12\x19\n" +
	"\bis_final\x18\x04 \x01(\bR\aisFinal\x12\x1d\n" +
	"\n" +
	"total_size\x18\x05 \x01(\x03R\ttotalSize\x12!\n" +
	"\fcontent_type\x18\x06 \x01(\tR\vcontentType\x12=\n" +
	"\aheaders\x18\a \x03(\v2#.tunnel.LargeFileChunk.HeadersEntryR\aheaders\x12\x1f\n" +
	"\vstatus_code\x18\b \x01(\x05R\n" +
	"statusCode\x12#\n" +
	"\rerror_message\x18\t \x01(\tR\ferrorMessage\x1a:\n" +
	"\fHeadersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xb1\x02\n" +
	"\x10HTTPRequestStart\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x16\n" +
	"\x06method\x18\x02 \x01(\tR\x06method\x12\x12\n" +
	"\x04path\x18\x03 \x01(\tR\x04path\x12\x14\n" +
	"\x05query\x18\x04 \x01(\tR\x05query\x12?\n" +
	"\aheaders\x18\x05 \x03(\v2%.tunnel.HTTPRequestStart.HeadersEntryR\aheaders\x12\x1b\n" +
	"\tclient_ip\x18\x06 \x01(\tR\bclientIp\x12\"\n" +
	"\ris_large_file\x18\a \x01(\bR\visLargeFile\x1a:\n" +
	"\fHeadersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"E\n" +
	"\x10HTTPRequestChunk\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x12\n" +
	"\x04data\x18\x02 \x01(\fR\x04data\"/\n" +
	"\x0eHTTPRequestEnd\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\"\xf2\x02\n" +
	"\rTunnelControl\x127\n" +
	"\thandshake\x18\x01 \x01(\v2\x17.tunnel.TunnelHandshakeH\x00R\thandshake\x12.\n" +
	"\x06status\x18\x02 \x01(\v2\x14.tunnel.TunnelStatusH\x00R\x06status\x12.\n" +
	"\x06config\x18\x03 \x01(\v2\x14.tunnel.TunnelConfigH\x00R\x06config\x121\n" +
	"\ametrics\x18\x04 \x01(\v2\x15.tunnel.TunnelMetricsH\x00R\ametrics\x12M\n" +
	"\x11establish_request\x18\x05 \x01(\v2\x1e.tunnel.TunnelEstablishRequestH\x00R\x10establishRequest\x12\x18\n" +
	"\amessage\x18\n" +
	" \x01(\tR\amessage\x12\x1c\n" +
	"\ttimestamp\x18\v \x01(\x03R\ttimestampB\x0e\n" +
	"\fcontrol_type\"\xdc\x01\n" +
	"\x16TunnelEstablishRequest\x123\n" +
	"\vtunnel_type\x18\x01 \x01(\x0e2\x12.tunnel.TunnelTypeR\n" +
	"tunnelType\x12\x16\n" +
	"\x06domain\x18\x02 \x01(\tR\x06domain\x12\x1f\n" +
	"\vtarget_port\x18\x03 \x01(\x05R\n" +
	"targetPort\x12\x1d\n" +
	"\n" +
	"request_id\x18\x04 \x01(\tR\trequestId\x12\x1d\n" +
	"\n" +
	"timeout_ms\x18\x05 \x01(\x03R\ttimeoutMs\x12\x16\n" +
	"\x06reason\x18\x06 \x01(\tR\x06reason\"\x8d\x01\n" +
	"\fTunnelConfig\x12%\n" +
	"\x0emax_concurrent\x18\x01 \x01(\x05R\rmaxConcurrent\x12'\n" +
	"\x0ftimeout_seconds\x18\x02 \x01(\x05R\x0etimeoutSeconds\x12-\n" +
	"\x12enable_compression\x18\x03 \x01(\bR\x11enableCompression\"\xda\x02\n" +
	"\fErrorMessage\x122\n" +
	"\x04type\x18\x01 \x01(\x0e2\x1e.tunnel.ErrorMessage.ErrorTypeR\x04type\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12\x18\n" +
	"\adetails\x18\x03 \x01(\tR\adetails\x12\x12\n" +
	"\x04code\x18\x04 \x01(\x05R\x04code\x12\x1c\n" +
	"\tretryable\x18\x05 \x01(\bR\tretryable\"\xaf\x01\n" +
	"\tErrorType\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\x19\n" +
	"\x15AUTHENTICATION_FAILED\x10\x01\x12\x14\n" +
	"\x10TUNNEL_NOT_FOUND\x10\x02\x12\x17\n" +
	"\x13SERVICE_UNAVAILABLE\x10\x03\x12\x13\n" +
	"\x0fREQUEST_TIMEOUT\x10\x04\x12\x10\n" +
	"\fRATE_LIMITED\x10\x05\x12\x0f\n" +
	"\vCHUNK_ERROR\x10\x06\x12\x13\n" +
	"\x0fSTREAMING_ERROR\x10\a\"\x8e\x02\n" +
	"\fTunnelStatus\x12)\n" +
	"\x05state\x18\x01 \x01(\x0e2\x13.tunnel.TunnelStateR\x05state\x12\x16\n" +
	"\x06domain\x18\x02 \x01(\tR\x06domain\x12\x1f\n" +
	"\vtarget_port\x18\x03 \x01(\x05R\n" +
	"targetPort\x12!\n" +
	"\fconnected_at\x18\x04 \x01(\x03R\vconnectedAt\x12-\n" +
	"\x12active_connections\x18\x05 \x01(\x05R\x11activeConnections\x12#\n" +
	"\rlast_activity\x18\x06 \x01(\x03R\flastActivity\x12#\n" +
	"\rerror_message\x18\a \x01(\tR\ferrorMessage\"\xe6\x02\n" +
	"\rTunnelMetrics\x12%\n" +
	"\x0etotal_requests\x18\x01 \x01(\x03R\rtotalRequests\x12'\n" +
	"\x0ftotal_responses\x18\x02 \x01(\x03R\x0etotalResponses\x12(\n" +
	"\x10total_bytes_sent\x18\x03 \x01(\x03R\x0etotalBytesSent\x120\n" +
	"\x14total_bytes_received\x18\x04 \x01(\x03R\x12totalBytesReceived\x12%\n" +
	"\x0eactive_streams\x18\x05 \x01(\x03R\ractiveStreams\x12+\n" +
	"\x11chunked_transfers\x18\x06 \x01(\x03R\x10chunkedTransfers\x122\n" +
	"\x15average_response_time\x18\a \x01(\x01R\x13averageResponseTime\x12!\n" +
	"\ferrors_count\x18\b \x01(\x03R\verrorsCount\".\n" +
	"\x12HealthCheckRequest\x12\x18\n" +
	"\aservice\x18\x01 \x01(\tR\aservice\"\x8e\x02\n" +
	"\x13HealthCheckResponse\x12,\n" +
	"\x06status\x18\x01 \x01(\x0e2\x14.tunnel.HealthStatusR\x06status\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12/\n" +
	"\ametrics\x18\x03 \x01(\v2\x15.tunnel.TunnelMetricsR\ametrics\x12B\n" +
	"\adetails\x18\x04 \x03(\v2(.tunnel.HealthCheckResponse.DetailsEntryR\adetails\x1a:\n" +
	"\fDetailsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xa2\x01\n" +
	"\x0fRequestMetadata\x12'\n" +
	"\x04type\x18\x01 \x01(\x0e2\x13.tunnel.RequestTypeR\x04type\x12,\n" +
	"\bpriority\x18\x02 \x01(\x0e2\x10.tunnel.PriorityR\bpriority\x12\x1d\n" +
	"\n" +
	"timeout_ms\x18\x03 \x01(\x03R\ttimeoutMs\x12\x19\n" +
	"\btrace_id\x18\x04 \x01(\tR\atraceId\"\xba\x01\n" +
	"\x10ResponseMetadata\x12,\n" +
	"\x12processing_time_ms\x18\x01 \x01(\x03R\x10processingTimeMs\x12#\n" +
	"\rresponse_size\x18\x02 \x01(\x03R\fresponseSize\x126\n" +
	"\fcache_status\x18\x03 \x01(\x0e2\x13.tunnel.CacheStatusR\vcacheStatus\x12\x1b\n" +
	"\tserver_id\x18\x04 \x01(\tR\bserverId*h\n" +
	"\n" +
	"TunnelType\x12\x17\n" +
	"\x13TUNNEL_TYPE_UNKNOWN\x10\x00\x12\x13\n" +
	"\x0fTUNNEL_TYPE_TCP\x10\x01\x12\x14\n" +
	"\x10TUNNEL_TYPE_GRPC\x10\x02\x12\x16\n" +
	"\x12TUNNEL_TYPE_HYBRID\x10\x03*\xf1\x01\n" +
	"\vTunnelState\x12\x18\n" +
	"\x14TUNNEL_STATE_UNKNOWN\x10\x00\x12\x1b\n" +
	"\x17TUNNEL_STATE_CONNECTING\x10\x01\x12\x1a\n" +
	"\x16TUNNEL_STATE_CONNECTED\x10\x02\x12\x1f\n" +
	"\x1bTUNNEL_STATE_AUTHENTICATING\x10\x03\x12\x17\n" +
	"\x13TUNNEL_STATE_ACTIVE\x10\x04\x12\x1e\n" +
	"\x1aTUNNEL_STATE_DISCONNECTING\x10\x05\x12\x1d\n" +
	"\x19TUNNEL_STATE_DISCONNECTED\x10\x06\x12\x16\n" +
	"\x12TUNNEL_STATE_ERROR\x10\a*\x86\x01\n" +
	"\fHealthStatus\x12\x19\n" +
	"\x15HEALTH_STATUS_UNKNOWN\x10\x00\x12\x19\n" +
	"\x15HEALTH_STATUS_SERVING\x10\x01\x12\x1d\n" +
	"\x19HEALTH_STATUS_NOT_SERVING\x10\x02\x12!\n" +
	"\x1dHEALTH_STATUS_SERVICE_UNKNOWN\x10\x03*\x8b\x01\n" +
	"\vRequestType\x12\x18\n" +
	"\x14REQUEST_TYPE_UNKNOWN\x10\x00\x12\x14\n" +
	"\x10REQUEST_TYPE_API\x10\x01\x12\x16\n" +
	"\x12REQUEST_TYPE_MEDIA\x10\x02\x12\x17\n" +
	"\x13REQUEST_TYPE_STATIC\x10\x03\x12\x1b\n" +
	"\x17REQUEST_TYPE_LARGE_FILE\x10\x04*q\n" +
	"\bPriority\x12\x14\n" +
	"\x10PRIORITY_UNKNOWN\x10\x00\x12\x10\n" +
	"\fPRIORITY_LOW\x10\x01\x12\x13\n" +
	"\x0fPRIORITY_NORMAL\x10\x02\x12\x11\n" +
	"\rPRIORITY_HIGH\x10\x03\x12\x15\n" +
	"\x11PRIORITY_CRITICAL\x10\x04*\x85\x01\n" +
	"\vCacheStatus\x12\x18\n" +
	"\x14CACHE_STATUS_UNKNOWN\x10\x00\x12\x14\n" +
	"\x10CACHE_STATUS_HIT\x10\x01\x12\x15\n" +
	"\x11CACHE_STATUS_MISS\x10\x02\x12\x16\n" +
	"\x12CACHE_STATUS_STALE\x10\x03\x12\x17\n" +
	"\x13CACHE_STATUS_BYPASS\x10\x042\xe3\x01\n" +
	"\rTunnelService\x12C\n" +
	"\x0fEstablishTunnel\x12\x15.tunnel.TunnelMessage\x1a\x15.tunnel.TunnelMessage(\x010\x01\x12E\n" +
	"\x0fStreamLargeFile\x12\x18.tunnel.LargeFileRequest\x1a\x16.tunnel.LargeFileChunk0\x01\x12F\n" +
	"\vHealthCheck\x12\x1a.tunnel.HealthCheckRequest\x1a\x1b.tunnel.HealthCheckResponseB\tZ\a./protob\x06proto3"

var (
	file_tunnel_proto_rawDescOnce sync.Once
	file_tunnel_proto_rawDescData []byte
)

func file_tunnel_proto_rawDescGZIP() []byte {
	file_tunnel_proto_rawDescOnce.Do(func() {
		file_tunnel_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_tunnel_proto_rawDesc), len(file_tunnel_proto_rawDesc)))
	})
	return file_tunnel_proto_rawDescData
}

var file_tunnel_proto_enumTypes = make([]protoimpl.EnumInfo, 7)
var file_tunnel_proto_msgTypes = make([]protoimpl.MessageInfo, 25)
var file_tunnel_proto_goTypes = []any{
	(TunnelType)(0),                // 0: tunnel.TunnelType
	(TunnelState)(0),               // 1: tunnel.TunnelState
	(HealthStatus)(0),              // 2: tunnel.HealthStatus
	(RequestType)(0),               // 3: tunnel.RequestType
	(Priority)(0),                  // 4: tunnel.Priority
	(CacheStatus)(0),               // 5: tunnel.CacheStatus
	(ErrorMessage_ErrorType)(0),    // 6: tunnel.ErrorMessage.ErrorType
	(*TunnelMessage)(nil),          // 7: tunnel.TunnelMessage
	(*TunnelHandshake)(nil),        // 8: tunnel.TunnelHandshake
	(*TunnelCapabilities)(nil),     // 9: tunnel.TunnelCapabilities
	(*HTTPRequest)(nil),            // 10: tunnel.HTTPRequest
	(*HTTPResponse)(nil),           // 11: tunnel.HTTPResponse
	(*LargeFileRequest)(nil),       // 12: tunnel.LargeFileRequest
	(*LargeFileChunk)(nil),         // 13: tunnel.LargeFileChunk
	(*HTTPRequestStart)(nil),       // 14: tunnel.HTTPRequestStart
	(*HTTPRequestChunk)(nil),       // 15: tunnel.HTTPRequestChunk
	(*HTTPRequestEnd)(nil),         // 16: tunnel.HTTPRequestEnd
	(*TunnelControl)(nil),          // 17: tunnel.TunnelControl
	(*TunnelEstablishRequest)(nil), // 18: tunnel.TunnelEstablishRequest
	(*TunnelConfig)(nil),           // 19: tunnel.TunnelConfig
	(*ErrorMessage)(nil),           // 20: tunnel.ErrorMessage
	(*TunnelStatus)(nil),           // 21: tunnel.TunnelStatus
	(*TunnelMetrics)(nil),          // 22: tunnel.TunnelMetrics
	(*HealthCheckRequest)(nil),     // 23: tunnel.HealthCheckRequest
	(*HealthCheckResponse)(nil),    // 24: tunnel.HealthCheckResponse
	(*RequestMetadata)(nil),        // 25: tunnel.RequestMetadata
	(*ResponseMetadata)(nil),       // 26: tunnel.ResponseMetadata
	nil,                            // 27: tunnel.HTTPRequest.HeadersEntry
	nil,                            // 28: tunnel.HTTPResponse.HeadersEntry
	nil,                            // 29: tunnel.LargeFileChunk.HeadersEntry
	nil,                            // 30: tunnel.HTTPRequestStart.HeadersEntry
	nil,                            // 31: tunnel.HealthCheckResponse.DetailsEntry
}
var file_tunnel_proto_depIdxs = []int32{
	8,  // 0: tunnel.TunnelMessage.handshake:type_name -> tunnel.TunnelHandshake
	10, // 1: tunnel.TunnelMessage.http_request:type_name -> tunnel.HTTPRequest
	11, // 2: tunnel.TunnelMessage.http_response:type_name -> tunnel.HTTPResponse
	17, // 3: tunnel.TunnelMessage.control:type_name -> tunnel.TunnelControl
	20, // 4: tunnel.TunnelMessage.error:type_name -> tunnel.ErrorMessage
	21, // 5: tunnel.TunnelMessage.status:type_name -> tunnel.TunnelStatus
	14, // 6: tunnel.TunnelMessage.http_request_start:type_name -> tunnel.HTTPRequestStart
	15, // 7: tunnel.TunnelMessage.http_request_chunk:type_name -> tunnel.HTTPRequestChunk
	16, // 8: tunnel.TunnelMessage.http_request_end:type_name -> tunnel.HTTPRequestEnd
	9,  // 9: tunnel.TunnelHandshake.capabilities:type_name -> tunnel.TunnelCapabilities
	27, // 10: tunnel.HTTPRequest.headers:type_name -> tunnel.HTTPRequest.HeadersEntry
	25, // 11: tunnel.HTTPRequest.metadata:type_name -> tunnel.RequestMetadata
	28, // 12: tunnel.HTTPResponse.headers:type_name -> tunnel.HTTPResponse.HeadersEntry
	26, // 13: tunnel.HTTPResponse.metadata:type_name -> tunnel.ResponseMetadata
	10, // 14: tunnel.LargeFileRequest.http_request:type_name -> tunnel.HTTPRequest
	29, // 15: tunnel.LargeFileChunk.headers:type_name -> tunnel.LargeFileChunk.HeadersEntry
	30, // 16: tunnel.HTTPRequestStart.headers:type_name -> tunnel.HTTPRequestStart.HeadersEntry
	8,  // 17: tunnel.TunnelControl.handshake:type_name -> tunnel.TunnelHandshake
	21, // 18: tunnel.TunnelControl.status:type_name -> tunnel.TunnelStatus
	19, // 19: tunnel.TunnelControl.config:type_name -> tunnel.TunnelConfig
	22, // 20: tunnel.TunnelControl.metrics:type_name -> tunnel.TunnelMetrics
	18, // 21: tunnel.TunnelControl.establish_request:type_name -> tunnel.TunnelEstablishRequest
	0,  // 22: tunnel.TunnelEstablishRequest.tunnel_type:type_name -> tunnel.TunnelType
	6,  // 23: tunnel.ErrorMessage.type:type_name -> tunnel.ErrorMessage.ErrorType
	1,  // 24: tunnel.TunnelStatus.state:type_name -> tunnel.TunnelState
	2,  // 25: tunnel.HealthCheckResponse.status:type_name -> tunnel.HealthStatus
	22, // 26: tunnel.HealthCheckResponse.metrics:type_name -> tunnel.TunnelMetrics
	31, // 27: tunnel.HealthCheckResponse.details:type_name -> tunnel.HealthCheckResponse.DetailsEntry
	3,  // 28: tunnel.RequestMetadata.type:type_name -> tunnel.RequestType
	4,  // 29: tunnel.RequestMetadata.priority:type_name -> tunnel.Priority
	5,  // 30: tunnel.ResponseMetadata.cache_status:type_name -> tunnel.CacheStatus
	7,  // 31: tunnel.TunnelService.EstablishTunnel:input_type -> tunnel.TunnelMessage
	12, // 32: tunnel.TunnelService.StreamLargeFile:input_type -> tunnel.LargeFileRequest
	23, // 33: tunnel.TunnelService.HealthCheck:input_type -> tunnel.HealthCheckRequest
	7,  // 34: tunnel.TunnelService.EstablishTunnel:output_type -> tunnel.TunnelMessage
	13, // 35: tunnel.TunnelService.StreamLargeFile:output_type -> tunnel.LargeFileChunk
	24, // 36: tunnel.TunnelService.HealthCheck:output_type -> tunnel.HealthCheckResponse
	34, // [34:37] is the sub-list for method output_type
	31, // [31:34] is the sub-list for method input_type
	31, // [31:31] is the sub-list for extension type_name
	31, // [31:31] is the sub-list for extension extendee
	0,  // [0:31] is the sub-list for field type_name
}

func init() { file_tunnel_proto_init() }
func file_tunnel_proto_init() {
	if File_tunnel_proto != nil {
		return
	}
	file_tunnel_proto_msgTypes[0].OneofWrappers = []any{
		(*TunnelMessage_Handshake)(nil),
		(*TunnelMessage_HttpRequest)(nil),
		(*TunnelMessage_HttpResponse)(nil),
		(*TunnelMessage_Control)(nil),
		(*TunnelMessage_Error)(nil),
		(*TunnelMessage_Status)(nil),
		(*TunnelMessage_HttpRequestStart)(nil),
		(*TunnelMessage_HttpRequestChunk)(nil),
		(*TunnelMessage_HttpRequestEnd)(nil),
	}
	file_tunnel_proto_msgTypes[10].OneofWrappers = []any{
		(*TunnelControl_Handshake)(nil),
		(*TunnelControl_Status)(nil),
		(*TunnelControl_Config)(nil),
		(*TunnelControl_Metrics)(nil),
		(*TunnelControl_EstablishRequest)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_tunnel_proto_rawDesc), len(file_tunnel_proto_rawDesc)),
			NumEnums:      7,
			NumMessages:   25,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_tunnel_proto_goTypes,
		DependencyIndexes: file_tunnel_proto_depIdxs,
		EnumInfos:         file_tunnel_proto_enumTypes,
		MessageInfos:      file_tunnel_proto_msgTypes,
	}.Build()
	File_tunnel_proto = out.File
	file_tunnel_proto_goTypes = nil
	file_tunnel_proto_depIdxs = nil
}
