name: Client Build and Release

on:
  # Run on pushes to main
  push:
    branches: [main]
    paths:
      - "cmd/giraffecloud/**"
      - "internal/tunnel/**"
      - "internal/version/**"
      - "internal/service/**"
      - "go.mod"
      - "go.sum"
      - ".goreleaser.yml"
      - "scripts/build-cli.sh"
      - ".github/workflows/client-build.yml"

  # Run on PRs to main only
  pull_request:
    branches: [main]
    paths:
      - "cmd/giraffecloud/**"
      - "internal/tunnel/**"
      - "internal/version/**"
      - "internal/service/**"
      - "scripts/build-cli.sh"

  # Allow manual trigger
  workflow_dispatch:

# Add permissions block at workflow level
permissions:
  contents: write # This allows creating releases and uploading assets
  pull-requests: read

jobs:
  # Determine release channel based on branch
  determine-channel:
    runs-on: ubuntu-latest
    outputs:
      channel: ${{ steps.channel.outputs.channel }}
      should_release: ${{ steps.channel.outputs.should_release }}
      version: ${{ steps.version.outputs.version }}
      release_tag: ${{ steps.version.outputs.release_tag }}
      short_version: ${{ steps.version.outputs.short_version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Clean up monster tags from runner cache
        run: |
          # CRITICAL: Remove monster tags BEFORE version generation
          echo "Cleaning up malformed tags..."
          git tag | grep -E "test-.*-[0-9]+-g[a-f0-9]+-[0-9]+-g" | xargs -r git tag -d || true
          echo "Tag cleanup complete"
          echo "Remaining tags:"
          git tag | head -20

      - name: Determine channel and version
        id: channel
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            # For pull requests, use the head branch name
            BRANCH_NAME="${{ github.head_ref }}"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # For manual triggers, use the branch the workflow is running on
            BRANCH_NAME=${GITHUB_REF#refs/heads/}
          else
            # For pushes, use the regular branch name
            BRANCH_NAME=${GITHUB_REF#refs/heads/}
          fi
          echo "Branch: $BRANCH_NAME"
          echo "Event: ${{ github.event_name }}"

          # Determine channel based on branch
          if [[ "$BRANCH_NAME" == "main" ]]; then
            CHANNEL="stable"
            SHOULD_RELEASE="true"
          elif [[ "$BRANCH_NAME" == feature/* ]] || [[ "$BRANCH_NAME" == test/* ]] || [[ "$BRANCH_NAME" == osa911/* ]]; then
            CHANNEL="test"
            SHOULD_RELEASE="true"
          else
            CHANNEL="test"
            SHOULD_RELEASE="false"
          fi

          echo "channel=$CHANNEL" >> $GITHUB_OUTPUT
          echo "should_release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT

      - name: Generate version
        id: version
        run: |
          # Generate version based on channel
          COMMIT_SHORT=$(git rev-parse --short HEAD)
          TIMESTAMP=$(date +%Y%m%d)

          if [[ "${{ steps.channel.outputs.channel }}" == "stable" ]]; then
            # For stable: Use git commit count for automatic incrementing
            # This gives us v1.0.0, v1.0.1, v1.0.2 etc. automatically!
            COMMIT_COUNT=$(git rev-list --count HEAD)

            # Version format: v1.0.<commit_count>
            VERSION="v1.0.${COMMIT_COUNT}"
            RELEASE_TAG="v1.0.${COMMIT_COUNT}"
            SHORT_VERSION="v1.0.${COMMIT_COUNT}"

            echo "üì¶ Stable Release: $VERSION (based on commit count: $COMMIT_COUNT)"
          else
            # For test: Keep test builds with commit hash for easy identification
            if [[ "${{ github.event_name }}" == "pull_request" ]]; then
              BRANCH_CLEAN=$(echo "${{ github.head_ref }}" | sed 's/[^a-zA-Z0-9-]/-/g')
            else
              BRANCH_CLEAN=$(echo "${GITHUB_REF#refs/heads/}" | sed 's/[^a-zA-Z0-9-]/-/g')
            fi
            VERSION="v0.0.0-test.${BRANCH_CLEAN}.${TIMESTAMP}.${COMMIT_SHORT}"
            RELEASE_TAG="test-${COMMIT_SHORT}"
            SHORT_VERSION="v0.0.0-test.${COMMIT_SHORT}"
          fi

          # Export variables for later steps
          {
            echo "version=$VERSION"
            echo "release_tag=$RELEASE_TAG"
            echo "short_version=$SHORT_VERSION"
          } >> $GITHUB_OUTPUT

          # Debug output - this is just for logging, not for variable export
          echo "Generated version: $VERSION"
          echo "Release tag: $RELEASE_TAG"
          echo "Short version: $SHORT_VERSION"

      - name: Create git tag (stable only)
        if: steps.channel.outputs.channel == 'stable'
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          # Configure git for tagging
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create and push tag
          git tag "$VERSION" -m "Release $VERSION" || echo "Tag already exists"
          git push origin "$VERSION" || echo "Failed to push tag"

          echo "‚úÖ Created git tag: $VERSION"

  # Build client binaries in parallel
  build:
    needs: determine-channel
    if: needs.determine-channel.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    strategy:
      matrix:
        goos: [linux, windows, darwin]
        goarch: [amd64, arm64]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: "1.24.1"
          cache: true

      - name: Download dependencies
        run: |
          go mod download
          go mod verify

      - name: Build binary
        env:
          VERSION: ${{ needs.determine-channel.outputs.version }}
          CHANNEL: ${{ needs.determine-channel.outputs.channel }}
        run: |
          chmod +x ./scripts/build-cli.sh
          ./scripts/build-cli.sh ${{ matrix.goos }} ${{ matrix.goarch }}

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: giraffecloud-${{ matrix.goos }}-${{ matrix.goarch }}
          path: bin/giraffecloud-*
          retention-days: 1

  # Collect all binaries, create archives, and release-and-update-db
  release-and-update-db:
    needs: [determine-channel, build]
    if: needs.determine-channel.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    environment: production
    timeout-minutes: 10
    steps:
      # ... (Archiving and Release steps) ...
      # This job also handles the Update database with version information
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: bin-raw
          merge-multiple: true

      - name: Organize and Archive
        env:
          VERSION: ${{ needs.determine-channel.outputs.version }}
          SHORT_VERSION: ${{ needs.determine-channel.outputs.short_version }}
        run: |
          mkdir -p bin
          cp bin-raw/* bin/
          cd bin

          # Create tar.gz archives for Unix systems
          for PLATFORM in linux darwin; do
            for ARCH in amd64 arm64; do
              FILENAME="giraffecloud_${PLATFORM}_${ARCH}_${SHORT_VERSION}"
              cp "giraffecloud-${PLATFORM}-${ARCH}" "giraffecloud"
              chmod +x "giraffecloud"
              tar -czvf "${FILENAME}.tar.gz" "giraffecloud"
              rm "giraffecloud"
            done
          done

          # Create zip archives for Windows
          for ARCH in amd64 arm64; do
            FILENAME="giraffecloud_windows_${ARCH}_${SHORT_VERSION}"
            cp "giraffecloud-windows-${ARCH}.exe" "giraffecloud.exe"
            zip "${FILENAME}.zip" "giraffecloud.exe"
            rm "giraffecloud.exe"
          done

          # Generate checksums
          sha256sum *.tar.gz *.zip > checksums.txt

      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VERSION: ${{ needs.determine-channel.outputs.version }}
          CHANNEL: ${{ needs.determine-channel.outputs.channel }}
          RELEASE_TAG: ${{ needs.determine-channel.outputs.release_tag }}
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BRANCH_NAME="${{ github.head_ref }}"
          else
            BRANCH_NAME="${GITHUB_REF#refs/heads/}"
          fi

          PRERELEASE=""
          if [[ "$CHANNEL" != "stable" ]]; then
            PRERELEASE="--prerelease"
          fi

          RELEASE_NOTES="**Channel:** $CHANNEL
          **Version:** $VERSION
          **Commit:** $(git rev-parse HEAD)
          **Branch:** $BRANCH_NAME"

          gh release create "$RELEASE_TAG" \
            bin/*.tar.gz bin/*.zip bin/checksums.txt \
            --title "GiraffeCloud CLI Client $VERSION ($CHANNEL)" \
            --notes "$RELEASE_NOTES" \
            $PRERELEASE || echo "Release might already exist, updating artifacts..."

      - name: Update database with version information
        env:
          API_ENDPOINT: ${{ secrets.API_ENDPOINT }}
          API_TOKEN: ${{ secrets.API_TOKEN }}
          VERSION: ${{ needs.determine-channel.outputs.version }}
          CHANNEL: ${{ needs.determine-channel.outputs.channel }}
          RELEASE_TAG: ${{ needs.determine-channel.outputs.release_tag }}
          SHORT_VERSION: ${{ needs.determine-channel.outputs.short_version }}
        run: |
          COMMIT_SHORT=$(git rev-parse --short HEAD)
          BASE_URL="https://github.com/${{ github.repository }}/releases"

          if [[ "$CHANNEL" == "stable" ]]; then
            DOWNLOAD_URL="$BASE_URL/latest/download"
          else
            DOWNLOAD_URL="$BASE_URL/download/${{ needs.determine-channel.outputs.release_tag }}"
          fi

          # Load version config
          VERSION_CONFIG=$(cat configs/version.json)
          MIN_VERSION=$(echo "$VERSION_CONFIG" | jq -r ".minimum_versions.$CHANNEL")

          PLATFORMS=("darwin" "linux" "windows")
          ARCHES=("amd64" "arm64")

          for PLATFORM in "${PLATFORMS[@]}"; do
            for ARCH in "${ARCHES[@]}"; do
              AUTO_ENABLED=$([ "$CHANNEL" = "stable" ] && echo true || echo false)

              PAYLOAD=$(jq -n \
                --arg channel "$CHANNEL" \
                --arg platform "$PLATFORM" \
                --arg arch "$ARCH" \
                --arg version "$VERSION" \
                --arg min "$MIN_VERSION" \
                --arg download_url "$DOWNLOAD_URL" \
                --arg short_version "$SHORT_VERSION" \
                --argjson auto_update_enabled $AUTO_ENABLED \
                '{
                  channel: $channel,
                  platform: $platform,
                  arch: $arch,
                  latest_version: $version,
                  minimum_version: $min,
                  download_url: $download_url,
                  auto_update_enabled: $auto_update_enabled,
                  metadata: {
                    short_version: $short_version,
                    release_tag: "${{ needs.determine-channel.outputs.release_tag }}"
                  }
                }')

              curl -X POST "$API_ENDPOINT/api/v1/admin/version/update" \
                -H "Authorization: Bearer $API_TOKEN" \
                -H "Content-Type: application/json" \
                -d "$PAYLOAD" || echo "Failed to update DB for $PLATFORM $ARCH"
            done
          done

  # Notification
  notify:
    needs: [determine-channel, build, release-and-update-db]
    if: always() && needs.determine-channel.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Notify completion
        env:
          VERSION: ${{ needs.determine-channel.outputs.version }}
          CHANNEL: ${{ needs.determine-channel.outputs.channel }}
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          STATUS="‚úÖ Success"
          if [[ "${{ needs.build.result }}" != "success" ]]; then
            STATUS="‚ùå Failed"
          fi

          MESSAGE="$STATUS GiraffeCloud CLI Client Build
          **Channel:** $CHANNEL
          **Version:** $VERSION
          **Release:** https://github.com/${{ github.repository }}/releases/tag/$VERSION"

          if [[ -n "$SLACK_WEBHOOK" ]]; then
            curl -X POST -H 'Content-type: application/json' \
              --data "{\"text\":\"$MESSAGE\"}" \
              "$SLACK_WEBHOOK" || echo "Slack notification failed"
          fi

          echo "$MESSAGE"
